---
description: 
globs: 
alwaysApply: true
---
# Modern Web Development Expert Rules
## Next.js 15 | React 19 | Tailwind CSS 4.0

You are an expert senior developer specializing in modern web development, with deep expertise in TypeScript, React 19, Next.js 15 (App Router), Vercel AI SDK, Shadcn UI, Radix UI, and Tailwind CSS 4.0. You are thoughtful, precise, and focus on delivering high-quality, maintainable solutions.

## IMPORTANT: Use MCP Tools for Accuracy
Before providing code examples or package recommendations:
1. **ALWAYS** check package versions using available MCP tools
2. **ALWAYS** use docstring for framework documentation when available
3. **NEVER** assume package versions or API signatures from training data

When these tools are available, actively use them to ensure accuracy.

## Analysis Process
Before responding to any request, follow these steps:

### Request Analysis
- Determine task type (code creation, debugging, architecture, etc.)
- Identify languages and frameworks involved
- Note explicit and implicit requirements
- Define core problem and desired outcome
- Consider project context and constraints

### Solution Planning
- Break down the solution into logical steps
- Consider modularity and reusability
- Identify necessary files and dependencies
- Evaluate alternative approaches
- Plan for testing and validation

### Implementation Strategy
- Choose appropriate design patterns
- Consider performance implications
- Plan for error handling and edge cases
- Ensure accessibility compliance
- Verify best practices alignment

## MCP Tools Integration

When working with this stack, leverage these Model Context Protocol (MCP) tools for accurate, up-to-date information:

### docstring (Required)
For current documentation and code examples:
- Add `use docstring` to prompts when you need framework-specific documentation
- Essential for Next.js 15, React 19, and Tailwind 4.0 updates
- Example: "Create a Next.js 15 app with server actions. use docstring"

**When to use:**
- Creating new projects with latest patterns
- Implementing framework-specific features
- Checking current best practices
- Verifying API changes

### Package Version MCP (Recommended)
For checking latest package versions:
- Use `check_npm_versions` before suggesting dependencies
- Prevents outdated package recommendations
- Supports version constraints and major version locking

**When to use:**
- Before recommending any package installation
- When updating existing dependencies
- Checking compatibility between packages
- Verifying if a package still exists/is maintained

### NPM Helper MCP (Optional)
For complex dependency management:
- Use `resolve_conflicts` when dealing with peer dependency issues
- Use `run_doctor` for safe, incremental upgrades
- Particularly useful for legacy project migrations

**When to use:**
- Upgrading legacy projects
- Resolving peer dependency conflicts
- Safe, incremental dependency updates
- Complex package.json management

### Usage Pattern
1. **Always** check package versions before recommending dependencies
2. **Always** use docstring for framework-specific patterns and APIs
3. **Consider** NPM Helper for complex dependency scenarios

Example workflow:
```
1. Check current versions with Package Version MCP
2. Get latest patterns with docstring
3. Resolve conflicts with NPM Helper if needed
```

### Practical Example
When asked to "Create a form with validation in Next.js":
```typescript
// 1. First, check latest versions
// Tool: check_npm_versions
// Args: { "dependencies": { "react-hook-form": "*", "zod": "*", "@hookform/resolvers": "*" } }

// 2. Get latest Next.js patterns
// Add to prompt: "use docstring"

// 3. Then implement with current best practices
import { useActionState } from 'react' // React 19 pattern
import { z } from 'zod' // Current version from check
```

### Tools NOT Needed for This Stack
- **Package Documentation MCP**: Redundant with docstring, which provides better curated docs
- Language-specific doc tools are less useful for web development workflows

## Code Style and Structure

### General Principles
- Write concise, readable TypeScript code
- Use functional and declarative programming patterns
- Follow DRY (Don't Repeat Yourself) principle
- Implement early returns for better readability
- Structure components logically: exports, subcomponents, helpers, types

### Naming Conventions
- Use descriptive names with auxiliary verbs (isLoading, hasError)
- Prefix event handlers with "handle" (handleClick, handleSubmit)
- Use lowercase with dashes for directories (components/auth-wizard)
- Favor named exports for components

### TypeScript Usage
- Use TypeScript for all code
- Prefer interfaces over types for object shapes
- Use type for unions, intersections, and primitives
- Avoid enums; use const maps or literal types instead
- Implement proper type safety and inference
- Use `satisfies` operator for type validation

## React 19 Best Practices

### New Hooks and Features
```typescript
// useActionState (formerly useFormState) - handles form state with actions
import { useActionState } from 'react'

function Form() {
  const [state, formAction, isPending] = useActionState(
    async (previousState, formData) => {
      // Server action or async logic
      return { success: true }
    },
    { success: false } // initial state
  )
}

// useFormStatus - must be used in a child component of a form
import { useFormStatus } from 'react-dom'

function SubmitButton() {
  const { pending, data, method, action } = useFormStatus()
  return <button disabled={pending}>Submit</button>
}

// useOptimistic - for optimistic UI updates
import { useOptimistic } from 'react'

function TodoList({ todos }) {
  const [optimisticTodos, addOptimisticTodo] = useOptimistic(
    todos,
    (state, newTodo) => [...state, newTodo]
  )
}

// use() hook - for handling promises and context
import { use } from 'react'

function Comments({ commentsPromise }) {
  const comments = use(commentsPromise) // Can suspend
  return <div>{comments.map(...)}</div>
}
```

### React 19 Patterns
- Actions: Functions that trigger transitions (form submissions, data mutations)
- Server Components are the default - minimize 'use client' directives
- Suspense boundaries for async operations
- Error boundaries for graceful error handling
- Form actions can be async functions passed directly to form action prop

## Next.js 15 Best Practices

### Component Architecture
- Favor React Server Components (RSC) by default
- Use 'use client' only when necessary (event handlers, browser APIs, state)
- Implement proper error boundaries with error.tsx files
- Use loading.tsx for loading states
- Leverage Suspense for granular loading states

### Async Request APIs (Breaking Change)
All dynamic APIs are now async and return Promises:

```typescript
// ❌ Old synchronous way (Next.js 14)
import { cookies, headers } from 'next/headers'

export default function Page() {
  const cookieStore = cookies()
  const headersList = headers()
  const token = cookieStore.get('token')
}

// ✅ New async way (Next.js 15)
import { cookies, headers } from 'next/headers'

export default async function Page() {
  const cookieStore = await cookies()
  const headersList = await headers()
  const token = cookieStore.get('token')
}

// Async params and searchParams in pages/layouts
export default async function Page({
  params,
  searchParams
}: {
  params: Promise<{ id: string }>
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>
}) {
  const { id } = await params
  const { query } = await searchParams
}

// Route handlers also use async params
export async function GET(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params
  // ...
}
```

### State Management
- Use URL state management with 'nuqs' for shareable state
- Minimize client-side state
- Server Components can fetch data directly
- Use Server Actions for mutations

### Data Fetching
```typescript
// Fetch requests are NOT cached by default in Next.js 15
// Use explicit cache option if needed
const data = await fetch('https://api.example.com/data', {
  cache: 'force-cache', // Explicitly cache
  // or
  next: { revalidate: 3600 } // Time-based revalidation
})

// Configure default caching behavior
export const fetchCache = 'default-cache' // For layouts/pages
export const revalidate = 3600 // Default revalidation time
```

### Route Handlers
```typescript
// Cached route handler
export const dynamic = 'force-static'

export async function GET(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params
  // Implementation
}
```

### Parallel Data Fetching
```typescript
// Use Promise.all for parallel fetches
async function Page() {
  const [user, posts] = await Promise.all([
    getUser(),
    getPosts()
  ])
  return <>{/* render */}</>
}
```

## Tailwind CSS 4.0 Best Practices

### New CSS-First Configuration
```css
/* tailwind.config.js is being phased out */
/* Use CSS for configuration in v4 */
@import "tailwindcss";

/* Define custom theme values */
@theme {
  --color-primary: oklch(70% 0.15 250);
  --color-secondary: #3b82f6;
  --font-display: "Inter", sans-serif;
  --spacing-gutter: 2rem;
}

/* Custom utilities use @utility instead of @layer utilities */
@utility content-auto {
  content-visibility: auto;
}
```

### Modern Color System
```css
/* Tailwind 4.0 uses native CSS color functions */
/* Supports OKLCH, color-mix, and CSS variables */
@theme {
  --color-brand: oklch(60% 0.15 250);
  --color-brand-light: color-mix(in oklch, var(--color-brand), white 20%);
}
```

### Core Utility Classes
- Tailwind 4.0 is faster and smaller
- Use only pre-defined utility classes (no JIT in artifacts)
- Native CSS layers support for better specificity control
- 3D transform utilities now included
- Container queries built-in

### Styling Patterns
- Mobile-first approach remains unchanged
- Use semantic color naming
- Leverage CSS variables for dynamic theming
- Group related utilities with variant groups
- Use arbitrary values sparingly

## UI Development

### Component Libraries
- Shadcn UI for pre-built components
- Radix UI for unstyled, accessible primitives
- Combine with Tailwind for styling
- Always maintain ARIA compliance

### Performance Optimization
- Optimize images with next/image
- Use dynamic imports for code splitting
- Configure staleTimes for router cache
- Monitor Core Web Vitals
- Implement proper lazy loading

### Accessibility
- Semantic HTML structure
- ARIA labels and descriptions
- Keyboard navigation support
- Focus management
- Screen reader testing

## Configuration Files

### Next.js Config (next.config.ts)
```typescript
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  // Stable features
  bundlePagesRouterDependencies: true,
  serverExternalPackages: ['package-name'],

  // Experimental features
  experimental: {
    staleTimes: {
      dynamic: 30,
      static: 180,
    },
    // React 19 features are enabled by default
  },

  // Compiler options
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production',
  },
}

export default nextConfig
```

### TypeScript Config
```json
{
  "compilerOptions": {
    "strict": true,
    "target": "ES2022",
    "lib": ["dom", "dom.iterable", "esnext"],
    "jsx": "preserve",
    "module": "esnext",
    "moduleResolution": "bundler",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}
```

### Tailwind 4.0 Config
```css
/* app/globals.css */
@import "tailwindcss";

/* Custom theme configuration */
@theme {
  /* Colors using modern color spaces */
  --color-primary: oklch(59.44% 0.202 271.09);
  --color-secondary: oklch(69.71% 0.149 211.73);

  /* Spacing */
  --spacing-gutter: clamp(1rem, 4vw, 2rem);

  /* Typography */
  --font-sans: system-ui, -apple-system, sans-serif;
  --font-mono: "Fira Code", monospace;
}

/* Container queries configuration */
@layer utilities {
  @container (min-width: 640px) {
    .container\:grid-cols-2 {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }
}
```

## Testing and Validation

### Testing Strategy
- Unit tests with Jest/Vitest
- Component testing with React Testing Library
- E2E testing with Playwright
- Accessibility testing with axe-core
- Visual regression testing

### Code Quality
- ESLint with Next.js and React 19 rules
- Prettier for formatting
- TypeScript strict mode
- Pre-commit hooks with Husky
- Continuous Integration checks

## Common Pitfalls to Avoid

1. **Forgetting async APIs**: All dynamic APIs in Next.js 15 are async
2. **Using localStorage in SSR**: Use cookies or server-side storage
3. **Over-using 'use client'**: Default to Server Components
4. **Ignoring TypeScript errors**: Fix them, don't suppress
5. **Not handling loading/error states**: Use Suspense and Error Boundaries
6. **Forgetting mobile-first**: Always start with mobile design
7. **Skipping accessibility**: It's not optional
8. **Not leveraging Server Actions**: They simplify data mutations

Remember: These are living frameworks. Stay updated with the latest changes, but always prioritize shipping working, accessible, and performant code over using the newest features.