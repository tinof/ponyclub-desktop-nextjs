---
library: biomejs/biome
created_by: docfork.com
source: https://github.com/biomejs/biome
commit: de98918
updated_at: 2025-05-29T17:51:59Z
---


title: Installing Biome
description: Demonstrates how to install the Biome CLI as a development dependency using npm.  The `--save-dev` flag ensures it's only installed for development, and `--save-exact` specifies that the exact version should be saved in `package.json`.
source: README.md#_snippet_0

language: shell
code:
```
npm install --save-dev --save-exact @biomejs/biome
```

---

title: Installing critcmp
description: Demonstrates how to install `critcmp`, a tool used to compare benchmark results between different branches. This command is essential for performance analysis when developing.
source: xtask/bench/README.md#_snippet_0

language: bash
code:
```
cargo install critcmp
```

---

title: Installing Biome-JavaScript Formatter
description: Demonstrates how to install the Biome JavaScript formatter using npm. This command installs a nightly release, allowing users to test the latest features and bug fixes.
source: crates/biome_js_formatter/report-challenge.md#_snippet_0

language: sh
code:
```
npm install -D @biomejs/biome@1.3.3-nightly.ced82da
```

---

title: Installing Biome JavaScript Bindings
description: Demonstrates the installation of the `@biomejs/js-api` package and one of the `@biomejs/wasm-*` peer dependencies using npm.  The appropriate `@biomejs/wasm-*` package depends on the target platform (bundler, Node.js, or web).
source: packages/@biomejs/js-api/README.md#_snippet_0

language: shell
code:
```
npm i @biomejs/js-api
npm i @biomejs/wasm-<dist>
```

---

title: Running Fuzzers
description: Demonstrates how to execute a specific fuzzer using `cargo fuzz run`. This command includes flags to strip dead code, disable sanitizers (unless on Apple M1), and set a timeout.
source: fuzz/README.md#_snippet_0

language: bash
code:
```
cargo fuzz run --strip-dead-code -s none name_of_fuzzer -- -timeout=1
```

---

title: Running Coverage
description: Explains how to run the `cargo coverage` command to validate parser conformance against various test suites. It details the available subcommands, such as `compare`, and options like `--markdown`, `--json`, `--detailed`, `--suites`, and `--filter`.
source: xtask/coverage/README.md#_snippet_0

language: txt
code:
```
Run coverage command.
USAGE:
    cargo coverage <SUBCOMMAND> [option]
SUBCOMMANDS:
    compare             Compares output between two --json outputs
OPTIONS
    --markdown          Emits supported output into markdown format. Supported by `compare` subcommand.
    --json              Prints the test results in JSON. This mode will send all other test output and user messages to stderr.
    --detailed=[debug]  Prints a detailed summary at the end for all failing tests. Includes in depth details if set to `debug`.
    --suites=<IDS>      Runs the specified tests suites. Use comma as separator.
                        Valid values are:
                            *: will run all suites
                            js: will run all javascript suites; Same as "js/262";
                            ts: will run all typescript suites; Same as "ts/microsoft,ts/babel";
                            jsx: will run all jsx suites; Same as "jsx/babel";
                            js/262: will run https://github.com/tc39/test262/tree/main/test;
                            ts/microsoft: will run https://github.com/microsoft/Typescript/tree/main/tests/cases
                            ts/babel: will run https://github.com/babel/babel/tree/main/packages/babel-parser/test/fixtures/typescript
                            jsx/babel: will run https://github.com/babel/babel/tree/main/packages/babel-parser/test/fixtures/jsx/basic
                        Default is "*".
    --filter=<file>     Filters out tests that don't match the query.
    --help              Prints this help.
```

---

title: Running Biome Linter
description: Demonstrates a basic `test.sh` script that executes `biome lint` on the `src` directory. The test fails if any command fails or if `biome` reports lint errors, ensuring the linter functions correctly.
source: e2e-tests/README.md#_snippet_0

language: sh
code:
```
# fail if any command fail or if some variables are undefined
set -eu

cargo run --bin biome -- lint src
```

---

title: Comparing Coverage Results
description: Shows how to compare coverage results between two different runs, typically between a feature branch and the `main` branch. It uses `cargo coverage --json` to generate JSON output for both branches and then uses `cargo coverage compare` with the `--markdown` flag to produce a markdown report.
source: xtask/coverage/README.md#_snippet_1

language: bash
code:
```
# (commit your code on pr branch, run)
git checkout main
cargo coverage --json > base_results.json
git checkout <your branch>
cargo coverage --json > new_results.json
cargo coverage compare ./base_results.json ./new_results.json --markdown
```

---

title: Benchmarking Parser Performance
description: Illustrates how to benchmark the parser using `cargo bench` and compare results between the `main` branch and a feature branch using `critcmp`. This process identifies performance regressions or improvements introduced by code changes.
source: xtask/bench/README.md#_snippet_1

language: bash
code:
```
# (commit your code on pr branch, run)
git checkout main
cargo bench --bench js_parser -- --save-baseline main # You can also use css_parser
git checkout -
cargo bench --bench js_parser -- --save-baseline pr # You can also use css_parser
critcmp main pr
```

---

title: Benchmarking Formatter Performance
description: Illustrates how to benchmark the formatter using `cargo bench` and compare results between the `main` branch and a feature branch using `critcmp`. This process identifies performance regressions or improvements introduced by code changes.
source: xtask/bench/README.md#_snippet_2

language: bash
code:
```
# (commit your code on pr branch, run)
git checkout main
cargo bench --bench js_formatter -- --save-baseline main # You can also use css_formatter
git checkout -
cargo bench --bench js_formatter -- --save-baseline pr # You can also use css_formatter
critcmp main pr
```

---

title: Benchmarking Analyzer Performance
description: Illustrates how to benchmark the analyzer using `cargo bench` and compare results between the `main` branch and a feature branch using `critcmp`. This process identifies performance regressions or improvements introduced by code changes.
source: xtask/bench/README.md#_snippet_3

language: bash
code:
```
# (commit your code on pr branch, run)
git checkout main
cargo bench --bench js_analyzer -- --save-baseline main # You can also use css_analyzer
git checkout -
cargo bench --bench js_analyzer -- --save-baseline pr # You can also use css_analyzer
critcmp main pr
```

---

title: Deserializing Common Types - Rust
description: Demonstrates how to deserialize common Rust data structures like booleans, vectors, and hash maps from JSON strings. The example uses `deserialize_from_json_str` to deserialize a boolean, a vector of unsigned 8-bit integers, and a hash map of string-unsigned 8-bit integer pairs. It then asserts that the deserialized values match the expected values and that no diagnostics were generated.
source: crates/biome_deserialize/README.md#_snippet_0

language: rust
code:
```
use biome_deserialize::json::deserialize_from_json_str;
use biome_deserialize::Deserialized;
use biome_json_parser::JsonParserOptions;

let json = "false";
let Deserialized {
    deserialized,
    diagnostics,
} = deserialize_from_json_str::<bool>(&source, JsonParserOptions::default(), "path/to.json");
assert_eq!(deserialized, Some(false));
assert!(diagnostics.is_empty());

let json = "[0, 1]";
let Deserialized {
    deserialized,
    diagnostics,
} = deserialize_from_json_str::<Vec<u8>>(&source, JsonParserOptions::default(), "path/to.json");
assert_eq!(deserialized, Some(vec![0, 1]));
assert!(diagnostics.is_empty());

use std::collections::HashMap;
let json = r#"{ "a": 0, "b": 1 }"#;
let Deserialized {
    deserialized,
    diagnostics,
} = deserialize_from_json_str::<HashMap<String, u8>>(&source, JsonParserOptions::default(), "path/to.json");
assert_eq!(deserialized, Some(HashMap::from([("a".to_string(), 0), ("b".to_string(), 1)])));
assert!(diagnostics.is_empty());
```

---

title: Implementing Deserializable For a Struct - Rust
description: Illustrates how to implement the `Deserializable` trait for a custom struct, enabling JSON deserialization. The example defines a `Person` struct and a `PersonVisitor` to handle the deserialization logic. It demonstrates how to use the `DeserializationContext` and `DeserializableValue` traits to parse key-value pairs from a JSON map and populate the `Person` struct's fields.
source: crates/biome_deserialize/README.md#_snippet_0

language: rust
code:
```
use biome_deserialize::{DeserializationDiagnostic, Deserializable, DeserializationContext, DeserializableValue, DeserializationVisitor, Text, DeserializableTypes};
use biome_rowan::TextRange;

#[derive(Debug, Default, Eq, PartialEq, Clone)]
pub struct Person { name: String, age: u8 }

impl Deserializable for Person {
    fn deserialize(
        ctx: &mut impl DeserializationContext,
        value: &impl DeserializableValue,
        name: &str,
    ) -> Option<Self> {
        // Delegate the deserialization to `PersonVisitor`.
        // `value` will call the `PersonVisitor::viist_` method that corresponds to its type.
        value.deserialize(ctx, PersonVisitor, name)
    }
}

struct PersonVisitor;
impl DeserializationVisitor for PersonVisitor {
    // The visitor deserialize a [Person].
    type Output = Person;

    // We expect a `map` as data type.
    const EXPECTED_TYPE: DeserializableTypes = DeserializableTypes::MAP;

    // Because we expect a `map`, we have to implement the associated method `visit_map`.
    fn visit_map(
        self,
        ctx: &mut impl DeserializationContext,
        // Iterator of key-value pairs.
        members: impl Iterator<Item = Option<(impl DeserializableValue, impl DeserializableValue)>>,
        // range of the map in the source text.
        range: TextRange,
        _name: &str,
    ) -> Option<Self::Output> {
        let mut result = Person::default();
        for (key, value) in members.flatten() {
            // Try to deserialize the key as a string.
            // We use `Text` to avoid an heap-allocation.
            let Some(key_text) = Text::deserialize(ctx, &key, "") else {
                // If this failed, then pass to the next key-value pair.
                continue;
            };
            match key_text.text() {
                "name" => {
                    if let Some(name) = String::deserialize(ctx, &value, &key_text) {
                        result.name = name;
                    }
                },
                "age" => {
                    if let Some(age) = u8::deserialize(ctx, &value, &key_text) {
                        result.age = age;
                    }
                },
                unknown_key => {
                    const ALLOWED_KEYS: &[&str] = &["name"];
                    ctx.report(DeserializationDiagnostic::new_unknown_key(
                        unknown_key,
                        key.range(),
                        ALLOWED_KEYS,
                    ));
                }
            }
        }
        Some(result)
    }
}
```

---

title: Deserializing From Json String - Rust
description: Demonstrates how to deserialize a `Person` struct from a JSON string using `deserialize_from_json_str`. The example shows how to parse a JSON string representing a person's name, and then deserializes it to `Person` struct, asserting that the deserialization is successful and the resulting `Person` struct contains the expected data.
source: crates/biome_deserialize/README.md#_snippet_1

language: rust
code:
```
use biome_deserialize::json::deserialize_from_json_str;
use biome_json_parser::JsonParserOptions;

let source = r#"{ "name": "Isaac Asimov" }"#;
let deserialized = deserialize_from_json_str::<Person>(&source, JsonParserOptions::default(), "path/to.json");
assert!(!deserialized.has_errors());
assert_eq!(deserialized.into_deserialized(), Some(Person { name: "Isaac Asimov".to_string() }));
```

---

title: Generating Tests Using Macros
description: Demonstrates how to use the `tests_macros::gen_tests!` macro to automatically generate unit tests from files matching a glob pattern. The macro takes a glob pattern and a function to call with the full path to each file.
source: crates/tests_macros/README.md#_snippet_0

language: rust
code:
```
mod some_mod {
    tests_macros::gen_tests!{"tests/*.{js,json}", run_test}

    // input_file and expected_file are full paths
    fn run_test(input_file: &str, expected_file: &str) {
        println!("{:?} {:?}", input_file, expected_file); 
    }
}
```

---

title: Using Optional Chaining
description: Illustrates the use of the optional chaining operator (`?.`) to safely access nested properties of an object. It demonstrates various scenarios, including accessing properties, calling methods, and handling complex expressions involving the operator. The code shows how to avoid errors when a property might be `null` or `undefined`.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_1

language: diff
code:
```
 var street = user.address?.street;
 var fooValue = myForm.querySelector("input[name=foo]")?.value;
 
 obj?.prop;
 obj?.[expr];
 func?.(...args);
 
 a?.();
 a?.[++x];
 a?.b.c(++x).d;
 a?.b[3].c?.(x).d;
 a?.b.c;
-(a?.b).c;
+a?.b.c;
 a?.b?.c;
 delete a?.b;
 
 a?.b[3].c?.(x).d.e?.f[3].g?.(y).h;
 
-(a?.b).c();
-(a?.b[c]).c();
+a?.b.c();
+a?.b[c].c();
 
 a?.b?.c.d?.e;
 (a ? b : c)?.d;
 
 (list || list2)?.length;
 (list || list2)?.[list || list2];
 
 async function HelloWorld() {
   var x = (await foo.bar.blah)?.hi;
   a?.[await b];
   (await x)?.();
 }
 
 a[b?.c].d();
 a?.[b?.c].d();
 a[b?.c]?.d();
 a?.[b?.c]?.d();
 
 one?.fn();
-(one?.two).fn();
-(one?.two)();
-(one?.two())();
+one?.two.fn();
+one?.two();
+one?.two()();
 one.two?.fn();
-(one.two?.three).fn();
+one.two?.three.fn();
 one.two?.three?.fn();
 
 one?.();
-(one?.())();
+one?.()();
 one?.()?.();
 
-(one?.()).two;
+one?.().two;
 
 a?.[b ? c : d];
 
 (-1)?.toFixed();
 (void fn)?.();
 (a && b)?.();
 (a ? b : c)?.();
 (function () {})?.();
 (() => f)?.();
 (() => f)?.x;
-(a?.(x)).x;
+a?.(x).x;
 (
   aaaaaaaaaaaaaaaaaaaaaaaa &&
   aaaaaaaaaaaaaaaaaaaaaaaa &&
   aaaaaaaaaaaaaaaaaaaaaaaa
 )?.();
 
 let f = () => ({})?.();
 let g = () => ({})?.b;
 a = () => ({})?.() && a;
 a = () => ({})?.()() && a;
 a = () => ({})?.().b && a;
 a = () => ({})?.b && a;
 a = () => ({})?.b() && a;
 (a) => ({})?.()?.b && 0;
 (a) => ({})?.b?.b && 0;
 (x) => ({})?.()();
 (x) => ({})?.().b;
 (x) => ({})?.b();
 (x) => ({})?.b.b;
 ({})?.a().b();
 ({ a: 1 })?.entries();
 
 new (foo?.bar)();
 new (foo?.bar())();
 new (foo?.())();
```

---

title: Verifying Files in CI Environments
description: Illustrates how to verify all files against formatting, linting, and other checks in continuous integration (CI) environments. The `ci` command ensures code quality and consistency in the `./src` directory.
source: packages/@biomejs/biome/README.pt-BR.md#_snippet_4

language: shell
code:
```
```shell
# verificar todos os arquivos contra formatação, lint, etc. em ambientes CI
npx @biomejs/biome ci ./src
```
```

---

title: Running Biome Formatter
description: Illustrates how to run the Biome formatter on a directory of source files. The `--write` flag instructs Biome to overwrite the files with the formatted code.
source: packages/@biomejs/biome/README.uk.md#_snippet_1

language: shell
code:
```
# форматування файлів
npx @biomejs/biome format --write ./src
```

---

title: Running Biome Linter
description: Shows how to execute the Biome linter on a directory, applying safe fixes. The `--write` flag tells Biome to apply the fixes directly to the files.
source: packages/@biomejs/biome/README.uk.md#_snippet_2

language: shell
code:
```
# лінтинг файлів та застосування безпечних виправлень
npx @biomejs/biome lint --write ./src
```

---

title: Running Biome Check
description: Demonstrates how to run Biome's check command, which includes formatting, linting, and other checks. The `--write` flag applies safe fixes.
source: packages/@biomejs/biome/README.uk.md#_snippet_3

language: shell
code:
```
# запуск форматування, лінтингу тощо та застосування безпечних виправлень
npx @biomejs/biome check --write ./src
```

---

title: Running Biome CI
description: Illustrates how to use Biome in a CI environment to verify code formatting and linting. This command checks all files for compliance and is typically run in automated CI pipelines.
source: packages/@biomejs/biome/README.uk.md#_snippet_4

language: shell
code:
```
# перевірка всіх файлів на відповідність форматуванню, лінтингу тощо в середовищах CI
npx @biomejs/biome ci ./src
```

---

title: Formatting Files
description: Demonstrates how to format files using the Biome CLI. This command uses `npx` to execute the `format` command from the `@biomejs/biome` package, writing the formatted output directly to the specified files in the `./src` directory.
source: packages/@biomejs/biome/README.ja.md#_snippet_1

language: shell
code:
```
# ファイルをformatする
npx @biomejs/biome format --write ./src
```

---

title: Linting Files
description: Illustrates how to lint files using the Biome CLI. The command uses `npx` to execute the `lint` command from the `@biomejs/biome` package, analyzing the files in the `./src` directory for potential issues.
source: packages/@biomejs/biome/README.ja.md#_snippet_2

language: shell
code:
```
# ファイルをlintする
npx @biomejs/biome lint ./src
```

---

title: Checking and Applying Safe Suggestions
description: Demonstrates how to run format, lint, and apply safe suggestions using the Biome CLI. This command uses `npx` to execute the `check` command from the `@biomejs/biome` package, writing the changes directly to the specified files in the `./src` directory.
source: packages/@biomejs/biome/README.ja.md#_snippet_3

language: shell
code:
```
# format、lintなどを実行し、安全な提案を適用する
npx @biomejs/biome check --write ./src
```

---

title: Running Biome in CI Environments
description: Illustrates how to check formatting and linting in a CI environment using the Biome CLI. The command uses `npx` to execute the `ci` command from the `@biomejs/biome` package, targeting all files in the `./src` directory.
source: packages/@biomejs/biome/README.ja.md#_snippet_4

language: shell
code:
```
# CI環境では、すべてのファイルを対象にformatやlintをチェックする
npx @biomejs/biome ci ./src
```

---

title: Using Biome Commands
description: Demonstrates the usage of Biome commands via `npx`. The first command formats files, the second lints and applies safe fixes, the third executes formatting, linting, and applies safe fixes, and the last checks all files against formatting and linting in CI environments.
source: packages/@biomejs/biome/README.fr.md#_snippet_1

language: shell
code:
```
# formater les fichiers
npx @biomejs/biome format --write ./src

# linter les fichiers et appliquer les corrections sûres
npx @biomejs/biome lint --write ./src

# exécuter le formatage, le linting, etc. et appliquer les corrections sûres
npx @biomejs/biome check --write ./src

# vérifier tous les fichiers par rapport au formatage, au linting, etc. dans les environnements d’intégration continue
npx @biomejs/biome ci ./src
```

---

title: Using Biome for Formatting, Linting, and Checking
description: Illustrates the basic usage of Biome CLI commands. The `format` command formats files, `lint` lints files, and `check` performs formatting, linting, and other checks, with the `--write` flag applying safe fixes. The `ci` command is used for continuous integration to perform checks.
source: packages/@biomejs/biome/README.ru.md#_snippet_1

language: shell
code:
```
# форматирование файлов
npx @biomejs/biome format --write ./src

# линт файлов и применение безопасных изменений
npx @biomejs/biome lint --write ./src

# форматирование, линт и другие проверки, а также применение безопасных изменений
npx @biomejs/biome check --write ./src

# форматирование, линт и другие проверки в CI
npx @biomejs/biome ci ./src
```

---

title: Linting Files
description: Illustrates how to lint files using the Biome CLI. This command analyzes the specified files for potential errors and style violations.
source: packages/@biomejs/biome/README.hi.md#_snippet_1

language: shell
code:
```
npx @biomejs/biome lint ./src
```

---

title: Checking All Files in CI Environment
description: Demonstrates how to check all files against format and lint rules in a CI environment using the Biome CLI.  This ensures code quality and consistency in automated builds.
source: packages/@biomejs/biome/README.hi.md#_snippet_3

language: shell
code:
```
npx @biomejs/biome ci ./src
```

---

title: Using Biome to Format and Lint JavaScript
description: Illustrates how to use the `@biomejs/js-api` to format and lint JavaScript code. It imports the `Biome` and `Distribution` classes, creates a `Biome` instance, opens a project, formats content, and then lints the formatted content. The example also shows how to print diagnostics to HTML.
source: packages/@biomejs/js-api/README.md#_snippet_1

language: js
code:
```
import { Biome, Distribution } from "@biomejs/js-api";

const biome = await Biome.create({
	distribution: Distribution.NODE, // Or BUNDLER / WEB depending on the distribution package you've installed
});

const projectKey = biome.openProject('path/to/project/dir');

// Optionally apply a Biome configuration (instead of biome.json)
biome.applyConfiguration(projectKey, {...});

const formatted = biome.formatContent("function f   (a, b) { return a == b; }", {
	filePath: "example.js",
});

console.log('Formatted content: ', formatted.content);

const result = biome.lintContent(formatted.content, {
	filePath: "example.js",
});

const html = biome.printDiagnostics(result.diagnostics, {
	filePath: "example.js",
	fileSource: formatted.content,
});

console.log('Lint diagnostics: ', html);
```

---

title: Formatting Content from Standard Input - CLI
description: Illustrates how to format code content directly from standard input using the `rome format` command. The `--stdin-file-path` argument is mandatory and specifies a file name with its extension, helping Rome determine the language and formatting rules.
source: ROME_CHANGELOG.md#_snippet_1

language: shell
code:
```
echo "function f() { return {} }" | rome format --stdin-file-path example.js
```

---

title: Printing Messages and Diagnostics
description: Demonstrates how to use the `Console` trait to print messages formatted with markup and diagnostics. The code shows examples of using `console.message` and `console.diagnostic` to output information to the user.
source: crates/biome_console/README.md#_snippet_0

language: rust
code:
```
console.message(markup! {
    <Info>"Processed "<Emphasis>{count}</Emphasis>" files"</Info>
});

console.diagnostic(
    &mut files,
    Diagnostics::error(file_id, code, title),
);
```

---

title: Diffing Array Numbers With Holes
description: Demonstrates the formatting of arrays containing numbers and holes, including comments before and after the holes. The code shows the differences between the original and formatted versions using diff annotations.
source: crates/biome_js_formatter/report.md#_snippet_0

language: diff
code:
```
 const numberWithHoles1 = [
   7234932941,
   7234932722,
   7234932312,
   ,
   // comment before a hole 1
   7234932841,
   ,
   7234932843,
   ,
   // comment after a hole 1
   7234932436,
 ];
 
 const numberWithHoles2 = [
   0x234932941,
   0x234932722,
   0x234932312,
-
   ,
   // comment before a hole 2
   0x234932841,
   ,
   0x234932843,
   ,
+
   // comment after a hole 2
   0x234932436,
 ];
```

---

title: Diffing Curried Arrow Functions
description: Illustrates the formatting of curried arrow functions, including those with ternary expressions and long conditions. The code highlights the differences between the original and formatted versions using diff annotations.
source: crates/biome_js_formatter/report.md#_snippet_1

language: diff
code:
```
 Y(() => (a ? b : c));
 
 Y(() => () => (a ? b : c));
 
 Y(() => () => () => (a ? b : c));
 
 Y(() =>
   longlonglonglonglonglonglonglonglonglongCondition
     ? "Prettier is an opinionated code formatter."
     : "Prettier takes your code and reprints it from scratch by taking the line length into account.",
 );
 
 Y(
   () => () =>
     longlonglonglonglonglonglonglonglonglongCondition
       ? "Prettier is an opinionated code formatter."
       : "Prettier takes your code and reprints it from scratch by taking the line length into account.",
 );
 
 Y(
   () => () => () =>
     longlonglonglonglonglonglonglonglonglongCondition
       ? "Prettier is an opinionated code formatter."
       : "Prettier takes your code and reprints it from scratch by taking the line length into account.",
 );
 
 const x1 = () => [
   "The",
   "green",
   "dragon",
   "liked",
   "to",
   "knit",
   "sweaters",
   "for",
   "the",
   "fluffy",
   "clouds",
   "in",
   "the",
   "sky.",
 ];
 
 const x2 = () => () => [
   "The",
   "green",
   "dragon",
   "liked",
   "to",
   "knit",
   "sweaters",
   "for",
   "the",
   "fluffy",
   "clouds",
   "in",
   "the",
   "sky.",
 ];
 
 const x3 = () => () => () => [
   "The",
   "green",
   "dragon",
   "liked",
   "to",
   "knit",
   "sweaters",
   "for",
   "the",
   "fluffy",
   "clouds",
   "in",
   "the",
   "sky.",
 ];
 
 f((a) => (1, 2, 3) /* a */);
 f((a) => (b) => (1, 2, 3) /* b */ /* a */);
-f((a) => (b) => (c) => (1, 2, 3) /* c */ /* b */ /* a */);
+f((a) => (b) => (c) => (1, 2, 3) /* b */ /* c */ /* a */);
 
 f((a) => (1 ? 2 : 3) /* a */);
 f((a) => (b) => (1 ? 2 : 3) /* b */ /* a */);
-f((a) => (b) => (c) => (1 ? 2 : 3) /* c */ /* b */ /* a */);
+f((a) => (b) => (c) => (1 ? 2 : 3) /* b */ /* c */ /* a */);
 
 a(
   "",
   "",
   ({}) =>
     () =>
     () =>
     () =>
     () =>
     () =>
     () =>
       test,
 );
 a(
   "",
   "",
   ({}) =>
     () =>
     () =>
     () =>
     () =>
     () =>
     () =>
       test ? 1 : 2,
 );
```

---

title: Diffing Newline Before Arrow Function
description: Shows the change related to newline insertion before an arrow function. Demonstrates the impact of the formatting change using diff output.
source: crates/biome_js_formatter/report.md#_snippet_2

language: diff
code:
```
-async (x) => x;
+async;
+x;
+=> x
```

---

title: Using React Hooks with useEffect and useMemo
description: Demonstrates the usage of `useEffect` and `useMemo` hooks in React components. It shows how to define effect dependencies and memoize values based on dependencies, optimizing component re-renders.
source: crates/biome_js_formatter/report.md#_snippet_0

language: javascript
code:
```
function helloWorld() {
  useEffect(() => {
    // do something
  }, [props.value]);
  useEffect(() => {
    // do something
  }, [
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
  ]);
}

function helloWorldWithReact() {
  React.useEffect(() => {
    // do something
  }, [props.value]);
  React.useEffect(() => {
    // do something
  }, [
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
  ]);
}

function MyComponent(props) {
  useEffect(
    () => {
      console.log("some code", props.foo);
    },

    // We need to disable the eslint warning here,
    // because of some complicated reason.
    // eslint-disable line react-hooks/exhaustive-deps
    [],
  );

  return null;
}

function Comp1() {
  const { firstName, lastName } = useMemo(
    () => parseFullName(fullName),
    [fullName],
  );
}

function Comp2() {
  const { firstName, lastName } = useMemo(
    () => func(),
    [
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
    ],
  );
}

function Comp3() {
  const { firstName, lastName } = useMemo(
    (aaa, bbb, ccc, ddd, eee, fff, ggg, hhh, iii, jjj, kkk) =>
      func(aaa, bbb, ccc, ddd, eee, fff, ggg, hhh, iii, jjj, kkk),
    [foo, bar, baz],
  );
}

function Comp4() {
  const { firstName, lastName } = useMemo(
    () =>
      (foo && bar && baz) ||
      baz ||
      (foo && baz(foo) + bar(foo) + foo && bar && baz) ||
      baz ||
      (foo && baz(foo) + bar(foo)),
    [foo, bar, baz],
  );
}

function Comp5() {
  const { firstName, lastName } = useMemo(() => func(), [foo]);
}
```

---

title: Formatting Member Chain Expressions
description: Demonstrates how to format long member chains across multiple lines for improved readability. The code shows different scenarios, including chained methods, property access, and conditional expressions, ensuring proper indentation and line breaks to maintain code clarity.
source: crates/biome_js_formatter/report.md#_snippet_0

language: diff
code:
```
 fooBar
   .doSomething("Hello World")
   .doAnotherThing("Foo", { foo: bar })
 
   // App configuration.
   .doOneMoreThing(config)
 
   .run(() => console.log("Bar"));
 
 bigDeal
 
   .doSomething("Hello World")
 
   // Hello world
   .doAnotherThing("Foo", { foo: bar })
 
   // App configuration.
   .doOneMoreThing(config)
 
   .run(() => console.log("Bar"));
 
 foo.bar.baz
 
   .doSomething("Hello World")
 
   // Hello world
   .foo.bar.doAnotherThing("Foo", { foo: bar })
 
   .doOneMoreThing(config)
   .bar.run(() => console.log("Bar"));
 
 (somethingGood ? thisIsIt : maybeNot)
 
   // Hello world
   .doSomething("Hello World")
 
   .doAnotherThing("Foo", { foo: bar }) // Run this
   .run(() => console.log("Bar")); // Do this
 
 helloWorld
 
   .text()
 
   .then((t) => t);
 
 (
   veryLongVeryLongVeryLong ||
   anotherVeryLongVeryLongVeryLong ||
   veryVeryVeryLongError
 )
 
   .map((tickets) => TicketRecord.createFromSomeLongString())
 
   .filter((obj) => !!obj);
 
 const sel = this.connections
 
   .concat(this.activities.concat(this.operators))
   .filter((x) => x.selected);
```

---

title: Fixing Comment Placement in Arrow Functions - TypeScript
description: Demonstrates how to correctly place comments within arrow functions in TypeScript. It shows how to avoid incorrect comment placement that can occur when formatting arrow functions.
source: crates/biome_js_formatter/report.md#_snippet_0

language: typescript
code:
```
 const fn1 = () => {
   return;
-}; /* foo */
+} /* foo */;
```

---

title: Correcting Generic Type Definition for Arrow Functions - TypeScript
description: Demonstrates how to correct the generic type definition for arrow functions in TypeScript to fix formatting issues. It shows the correct syntax for defining generic type parameters in arrow functions.
source: crates/biome_js_formatter/report.md#_snippet_4

language: typescript
code:
```
 const foo1 =
   // comment
-
-    <T,>() =>
+    <T>() =>
     () =>
       1;
 
 const foo2 =
   // comment
   () => () => 1;
 
 const foo3 =
   // comment
-  <T,>() => 1;
+  <T>() => 1;
 
 foo(
   // comment
-  <T,>() =>
+  <T>() =>
     () =>
       1,
 );
 
 a ||
   // comment
-  (<T,>() =>
+  (<T>() =>
     () =>
       1);
 
 void (
   // comment
-  (<T,>() =>
+  (<T>() =>
     () =>
       1)
 );
 
 cond
   ? // comment
-    <T,>() =>
+    <T>() =>
       () =>
         1
   : // comment
-    <T,>() =>
+    <T>() =>
       () =>
         1;
 
 foo4 =
   // comment
-
-    <T,>() =>
+    <T>() =>
     () =>
       1;
```

---

title: Fixing Ternary Operator Formatting
description: Addresses formatting regressions in ternary operators, ensuring visual distinction between consequent and alternate expressions. Improves readability in complex conditional assignments and nested ternary expressions by adjusting indentation and parenthesis usage.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_0

language: javascript
code:
```
 const avatar = has_ordered
   ? "https://marmelab.com/posters/avatar/longer-word-that-breaks-consequent-" +
     numberOfCustomers +
     ".jpeg"
   : undefined;
 
 // Similarly, in the alternate:
 const redirectUrl = pathName
   ? pathName
   : nextPathName + nextSearch ||
     defaultAuthParams.afterLoginUrl.makeThisLongerSoItBreaks;
 
 // And another, more pathological case of the above:
 const isEmpty = (obj) =>
   obj instanceof Date
     ? false
     : obj === "" ||
       obj === null ||
       obj === undefined ||
       obj === somethingThatIsLonger ||
       shallowEqual(obj, {});
 
 // Again, this case is a bit hard to distinguish the alternate.
 const eventsFromOrders =
   orderIds && orders
     ? orderIds.map((id) => ({
         type: "order",
         date: orders[id].date,
         data: orders[id],
       }))
     : [];
 
 // Kinda weird to have dedents to the level of "return" in a function.
 function foo() {
   return !linkTo
     ? false
     : typeof linkTo === "function"
       ? linkTo(record, reference)
       : linkToRecord(rootPath, sourceId, linkTo_as_string);
 }
 function foo2() {
   return React.isValidElement(emptyText)
     ? React.cloneElement(emptyText)
     : emptyText === ""
       ? " " // em space, forces the display of an empty line of normal height
       : translate(emptyText, { _: emptyText });
 }
 
 // Function call ideally wouldnt break break
 const matchingReferencesError = isMatchingReferencesError(matchingReferences)
   ? translate(matchingReferences.error, {
       _: matchingReferences.error,
     })
   : null;
 
 // This one is kinda confusing any way you slice it...
 const obj = {
   error:
     matchingReferencesError &&
     (!input.value ||
       (input.value && selectedReferencesDataStatus === REFERENCES_STATUS_EMPTY))
       ? translate("ra.input.references.all_missing", {
           _: "ra.input.references.all_missing",
         })
       : null,
 };
 
 // I think we should indent after the inner || on this, and do better wtih the parens around the &&
 const obj2 = {
   warning:
     matchingReferencesError ||
     (input.value && selectedReferencesDataStatus !== REFERENCES_STATUS_READY)
       ? matchingReferencesError ||
         translate("ra.input.references.many_missing", {
           _: "ra.input.references.many_missing",
         })
       : null,
 };
 
 // The boolean conditions in the test should look cohesive.
 const selectedReferencesDataStatus =
   !isEmpty(value) && typeof value === "string" && !pattern.test(value)
     ? getMessage(message, { pattern }, value, values)
     : undefined;
 
 // Would be nice if these two nested ternaries didn't look like a single one.
 resolveRedirectTo(
   redirectTo,
   basePath,
   payload
     ? payload.id || (payload.data ? payload.data.id : null)
     : requestPayload
       ? requestPayload.id
       : null,
   payload && payload.data
     ? payload.data
     : requestPayload && requestPayload.data
       ? requestPayload.data
       : null,
 );
 
 const delayedDataProvider = new Proxy(restProvider, {
   get: (target, name, self) =>
-    name === "then" // as we await for the dataProvider, JS calls then on it. We must trap that call or else the dataProvider will be called with the then method
-      ? self
+    name === "then"
+      ? // as we await for the dataProvider, JS calls then on it. We must trap that call or else the dataProvider will be called with the then method
+        self
       : (resource, params) =>
           new Promise((resolve) =>
             setTimeout(
               () => resolve(restProvider[name](resource, params)),
               500,
             ),
           ),
 });
 
 function foo4() {
   return !match || match.length < 5
     ? line
     : match[1] + match[2] + match[3] + match[4];
 }
 
 function foo5() {
   return !match || match.length < 5
     ? foo(line)
     : match[1] + match[2] + match[3] + match[4];
 }
 
 function foo6() {
   return !match || match.length < 5
     ? linethatisverylongandbreaksthelinehooray
     : match[1] + match[2] + match[3] + match[4];
 }
 
 function foo7() {
   return !match || match.length < 5
     ? linethatisverylongandbreaksthelinehoorayjustabitlonger
     : match[1] + match[2] + match[3] + match[4];
 }
 
 const badComments = schema.model
   ? schema
   : // If model is an array where the items schema is a referred model then we need to use that
     schema.type === "array"
     ? schema.items
     : schema;
 
 const anotherBadComment = refModel
   ? // If we're in a shared params file then reference the model name directly
     inSharedParamsFile
     ? refModel
     : // If we're not in a shared params file then reference the in-file type
       classRef()
   : // We don't have a model name, use the in-file name
     classRef();
```

---

title: Fixing Parentheses Inside a For Loop - JavaScript
description: Demonstrates the correction of parentheses usage within a `for` loop's initializer. The code ensures that the `in` operator is correctly parsed and that the loop functions as intended.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_0

language: diff
code:
```
 for (
   var a = () => {
-    (b in c);
+    b in c;
   };
   ;
-
```

---

title: Formatting Curried Arrow Functions
description: Demonstrates the formatting of curried arrow functions with varying numbers of arguments and return types. Shows how the formatter handles different levels of nesting and line breaks within these functions. The final snippet shows the usage of `import` in a curried arrow function.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_0

language: javascript
code:
```
const fn1 = (a) => 3;
const fn2 = (a) => (b) => 3;
const fn3 = (a) => (b) => (c) => 3;
const fn4 = (a) => (b) => (c) => (d) => 3;
const fn5 = (a) => (b) => (c) => (d) => (e) => 3;
const fn6 = (a) => (b) => (c) => (d) => (e) => (g) => 3;
const fn7 = (a) => (b) => (c) => (d) => (e) => (g) => (f) => 3;

const fn8 = (a) => ({ foo: bar, bar: baz, baz: foo });
const fn9 = (a) => (b) => ({ foo: bar, bar: baz, baz: foo });
const fn10 = (a) => (b) => (c) => ({ foo: bar, bar: baz, baz: foo });
const fn11 = (a) => (b) => (c) => (d) => ({ foo: bar, bar: baz, baz: foo });
const fn12 = (a) => (b) => (c) => (d) => (e) => ({
  foo: bar,
  bar: baz,
  baz: foo,
});
const fn13 = (a) => (b) => (c) => (d) => (e) => (g) => ({
  foo: bar,
  bar: baz,
  baz: foo,
});
const fn14 = (a) => (b) => (c) => (d) => (e) => (g) => (f) => ({
  foo: bar,
  bar: baz,
  baz: foo,
});

const curryTest =
  (argument1) =>
  (argument2) =>
  (argument3) =>
  (argument4) =>
  (argument5) =>
  (argument6) =>
  (argument7) =>
  (argument8) =>
  (argument9) =>
  (argument10) =>
  (argument11) =>
  (argument12) => ({
    foo: argument1,
    bar: argument2,
  });

let curryTest2 =
  (argument1) =>
  (argument2) =>
  (argument3) =>
  (argument4) =>
  (argument5) =>
  (argument6) =>
  (argument7) =>
  (argument8) =>
  (argument9) =>
  (argument10) =>
  (argument11) =>
  (argument12) => {
    const foo = "foo";
    return foo + "bar";
  };

curryTest2 =
  (argument1) =>
  (argument2) =>
  (argument3) =>
  (argument4) =>
  (argument5) =>
  (argument6) =>
  (argument7) =>
  (argument8) =>
  (argument9) =>
  (argument10) =>
  (argument11) =>
  (argument12) => {
    const foo = "foo";
    return foo + "bar";
  };

throw (argument1) =>
  (argument2) =>
  (argument3) =>
  (argument4) =>
  (argument5) =>
  (argument6) =>
  (argument7) =>
  (argument8) =>
  (argument9) =>
  (argument10) =>
  (argument11) =>
  (argument12) => {
    const foo = "foo";
    return foo + "bar";
  };

foo(
  (argument1) =>
    (argument2) =>
    (argument3) =>
    (argument4) =>
    (argument5) =>
    (argument6) =>
    (argument7) =>
    (argument8) =>
    (argument9) =>
    (argument10) =>
    (argument11) =>
    (argument12) =>
      3,
);

foo((argument1) =>
  (argument2) =>
  (argument3) =>
  (argument4) =>
  (argument5) =>
  (argument6) =>
  (argument7) =>
  (argument8) =>
  (argument9) =>
  (argument10) =>
  (argument11) =>
  (argument12) => ({
    foo: bar,
    bar: baz,
    baz: foo,
  }));

foo((argument1) =>
  (argument2) =>
  (argument3) =>
  (argument4) =>
  (argument5) =>
  (argument6) =>
  (argument7) =>
  (argument8) =>
  (argument9) =>
  (argument10) =>
  (argument11) =>
  (argument12) => {
    const foo = "foo";
    return foo + "bar";
  });

(
  (argument1) =>
  (argument2) =>
  (argument3) =>
  (argument4) =>
  (argument5) =>
  (argument6) =>
  (argument7) =>
  (argument8) =>
  (argument9) =>
  (argument10) =>
  (argument11) =>
  (argument12) =>
    3
)(3);

bar(
  foo((argument1) =>
    (argument2) =>
    (argument3) =>
    (argument4) =>
    (argument5) =>
    (argument6) =>
    (argument7) =>
    (argument8) =>
    (argument9) =>
    (argument10) =>
    (argument11) =>
    (argument12) => ({
      foo: bar,
      bar: baz,
    }))
);

const baaaz =
  (aaaaa1, bbbbb1) =>
  (aaaaa2, bbbbb2) =>
  (aaaaa3, bbbbb3) =>
  (aaaaa4, bbbbb4) => ({
    foo: bar,
  });

new Fooooooooooooooooooooooooooooooooooooooooooooooooooo(
  (action) => (next) => (next) => (next) => (next) => (next) => (next) =>
    dispatch(action),
);

foo?.Fooooooooooooooooooooooooooooooooooooooooooooooooooo(
  (action) => (next) => (next) => (next) => (next) => (next) => (next) =>
    dispatch(action),
);

foo((action) => (action) => action);

import((argument1) =>
  (argument2) =>
  (argument3) =>
  (argument4) =>
  (argument5) =>
  (argument6) =>
  (argument7) =>
  (argument8) =>
  (argument9) =>
  (argument10) =>
  (argument11) =>
  (argument12) => {
    const foo = "foo";
    return foo + "bar";
  });
```

---

title: Formatting Nested Arrow Functions
description: Illustrates the formatting of nested arrow functions, including those with complex expressions and API calls. Demonstrates how the formatter handles line breaks and indentation within these nested structures.  The example uses `request.get` with nested arrow functions.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_1

language: javascript
code:
```
const a = (x) => (y) => (z) =>
  x / 0.123456789 + (y * calculateSomething(z)) / Math.PI;

request.get("https://preview-9992--prettier.netlify.app", (head) => (body) => {
  console.log(head, body);
});

request.get("https://preview-9992--prettier.netlify.app", (head) =>
  (body) =>
  (mody) => {
    console.log(head, body);
  });

request.get("https://preview-9992--prettier.netlify.app", (head) =>
  (body) =>
  (modyLoremIpsumDolorAbstractProviderFactoryServiceModule) => {
    console.log(head, body);
  });
```

---

title: Formatting Curried Arrow Functions
description: Demonstrates the formatting of curried arrow functions with conditional expressions and long strings. This example showcases how the formatter handles complex arrow function structures and line breaks.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_0

language: javascript
code:
```
Y(() => (a ? b : c));
 
Y(() => () => (a ? b : c));
 
Y(() => () => () => (a ? b : c));
 
Y(() =>
  longlonglonglonglonglonglonglonglonglongCondition
    ? "Prettier is an opinionated code formatter."
    : "Prettier takes your code and reprints it from scratch by taking the line length into account.",
);
 
Y(
  () => () =>
    longlonglonglonglonglonglonglonglonglongCondition
      ? "Prettier is an opinionated code formatter."
      : "Prettier takes your code and reprints it from scratch by taking the line length into account.",
);
 
Y(
  () => () => () =>
    longlonglonglonglonglonglonglonglonglongCondition
      ? "Prettier is an opinionated code formatter."
      : "Prettier takes your code and reprints it from scratch by taking the line length into account.",
);
```

---

title: Formatting Array Returns in Curried Arrow Functions
description: Illustrates how array literals are formatted when returned from nested curried arrow functions. Shows the formatting of multi-line string arrays returned by a series of nested arrow functions.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_1

language: javascript
code:
```
const x1 = () => [
  "The",
  "green",
  "dragon",
  "liked",
  "to",
  "knit",
  "sweaters",
  "for",
  "the",
  "fluffy",
  "clouds",
  "in",
  "the",
  "sky.",
];

const x2 = () => () =>
  [
    "The",
    "green",
    "dragon",
    "liked",
    "to",
    "knit",
    "sweaters",
    "for",
    "the",
    "fluffy",
    "clouds",
    "in",
    "the",
    "sky.",
  ];

const x3 = () => () => () =>
  [
    "The",
    "green",
    "dragon",
    "liked",
    "to",
    "knit",
    "sweaters",
    "for",
    "the",
    "fluffy",
    "clouds",
    "in",
    "the",
    "sky.",
  ];
```

---

title: Formatting Comma-Separated Sequences in Arrow Functions
description: Demonstrates how comma-separated sequences are handled within arrow functions. This is important for understanding operator precedence and grouping within arrow function bodies.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_2

language: javascript
code:
```
f((a) => (1, 2, 3) /* a */);
f((a) => (b) => (1, 2, 3) /* b */ /* a */);
f((a) => (b) => (c) => (1, 2, 3) /* b */ /* c */ /* a */);

f((a) => (1 ? 2 : 3) /* a */);
f((a) => (b) => (1 ? 2 : 3) /* b */ /* a */);
f((a) => (b) => (c) => (1 ? 2 : 3) /* b */ /* c */ /* a */);
```

---

title: Formatting Deeply Nested Arrow Functions
description: Shows the formatting of deeply nested arrow functions, specifically focusing on the indentation and arrangement of multi-line function chains. These examples demonstrate the formatter's approach to maintaining readability in complex, nested arrow function structures.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_3

language: javascript
code:
```
a(
  "",
  "",
  ({}) =>
    () =>
    () =>
    () =>
    () =>
    () =>
    () =>
      test,
);
a(
  "",
  "",
  ({}) =>
    () =>
    () =>
    () =>
    () =>
    () =>
    () =>
      test ? 1 : 2,
);
```

---

title: Formatting Curried Functions with Rest Parameters
description: Demonstrates the correct formatting of curried functions, including those that use rest parameters.  This example shows how parameters are handled in curried functions, and how the formatter deals with the indentation.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_4

language: javascript
code:
```
const foobar =
  (argumentOne, argumentTwo, argumentThree) =>
  (...restOfTheArguments) => {
    return "baz";
  };
 
const foobaz =
  (argumentOne, argumentTwo, argumentThree) => (restOfTheArguments123, j) => {
    return "baz";
  };
```

---

title: Formatting Curried Functions With Default Parameters
description: Demonstrates formatting of curried functions that include default parameters. This is useful for understanding how the formatter handles default parameters in curried function contexts.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_5

language: javascript
code:
```
const makeSomeFunction = (services = { logger: null }) => (a, b, c) =>
  services.logger(a, b, c);

const makeSomeFunction2 =
  (
    services = {
      logger: null,
    },
  ) =>
  (a, b, c) =>
    services.logger(a, b, c);
```

---

title: Formatting Assignment with Long String
description: Shows how the formatter breaks long strings in object property assignments. This is useful to understand how the formatter handles long strings inside object properties.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_7

language: javascript
code:
```
params[
  "redirectTo"
] = `${window.location.pathname}${window.location.search}${window.location.hash}`;

params["redirectTo"]["codePointAt"][
  "name"
] = `${window.location.pathname}${window.location.search}${window.location.hash}`;

params.redirectTo.bar.bar.ba.barab[
  "foo"
].abr = `${window.location.pathname}${window.location.search}${window.location.hash}`;
```

---

title: Diffing Function Declarations With Comments
description: Demonstrates how comments are handled within function declarations and expressions in JavaScript. It shows comment placement between parentheses and function bodies, as well as within object methods.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_1

language: diff
code:
```
 function function_declaration() {
   // this is a function
   return 42;
 }
 
-(function named() {
-  // this is a function
-  return 42;
-})();
+// FIXME
+// TODO: reformat issue
+// (function named()
+// // this is a function
+// {
+//   return 42
+// })();
 
-(function () {
-  // this is a function
-  return 42;
-})();
+// FIXME
+// TODO: reformat issue
+// (function ()
+// // this is a function
+// {
+//   return 42
+// })();
 
 /* anonymous declaration */
 export default function () {
   // this is a function
   return 42;
 }
 
+// FIXME
+// TODO: reformat issue
 a = {
   foo() {
     // this is a function
   },
 
-  bar: function () {
-    // this is a function
-  },
+  // bar: function()
+  // // this is a function
+  // {},
 };
```

---

title: Using Destructuring with Default Values
description: Demonstrates how to use destructuring assignment with default values in JavaScript. Shows how to assign default values to variables when the corresponding property in the object or array is `null` or `undefined`. Highlights different use cases, including nested objects and functions.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_0

language: javascript
code:
```
const [one, two = null, three = null] = arr;
a = ([s = 1]) => 1;
const { children, ...props } = this.props;
 
const {
  user: { firstName, lastName },
} = this.props;
 
const {
  name: { first, last },
  organisation: {
    address: { street: orgStreetAddress, postcode: orgPostcode },
  },
} = user;
 
function f({ data: { name } }) {}
 
const UserComponent = function ({
  name: { first, last },
  organisation: {
    address: { street: orgStreetAddress, postcode: orgPostcode },
  },
}) {
  return;
};
 
const {
  a,
  b,
  c,
  d: { e },
} = someObject;
 
try {
  // code
} catch ({ data: { message } }) {
  // code
}
 
try {
  // code
} catch ({ data: { message: { errors } } }) {
  // code
}
 
const obj = {
  func(id, { blog: { title } }) {
    return id + title;
  },
};
 
class A {
  func(id, { blog: { title } }) {
    return id + title;
  }
}
```

---

title: Using Inject for AngularJS Testing
description: Illustrates how to use the `inject` function in AngularJS tests to inject services into `beforeEach`, `afterAll`, and `it` blocks. Demonstrates injecting `$fooService` and `$barService` into test functions and highlights how to inject services with long names.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_0

language: javascript
code:
```
 beforeEach(inject(($fooService, $barService) => {
   // code
 }));
 
 afterAll(inject(($fooService, $barService) => {
   console.log("Hello");
 }));
 
 it("should create the app", inject(($fooService, $barService) => {
   //code
 }));
 
 it("does something really long and complicated so I have to write a very long name for the test", inject(() => {
   // code
 }));
 
 it("does something really long and complicated so I have to write a very long name for the test", inject(($fooServiceLongName, $barServiceLongName) => {
   // code
 }));
 
 /*
  * isTestCall(parent) should only be called when parent exists
  * and parent.type is CallExpression. This test makes sure that
  * no errors are thrown when calling isTestCall(parent)
  */
 function x() {
   inject(() => {});
 }
```

---

title: Formatting Files
description: Illustrates how to format files using the Biome CLI. The `format` command with the `--write` flag applies formatting changes directly to the specified files in the `./src` directory.
source: packages/@biomejs/biome/README.pt-BR.md#_snippet_1

language: shell
code:
```
```shell
# formatar arquivos
npx @biomejs/biome format --write ./src
```
```

---

title: Linting Files
description: Shows how to lint files using the Biome CLI. The `lint` command analyzes the files in the `./src` directory for potential issues and displays diagnostic messages.
source: packages/@biomejs/biome/README.pt-BR.md#_snippet_2

language: shell
code:
```
```shell
# lintar arquivos
npx @biomejs/biome lint ./src
```
```

---

title: Running Checks and Applying Safe Fixes
description: Demonstrates how to run formatting, linting, and other checks using the Biome CLI, applying safe fixes. The `check` command with the `--write` flag automatically corrects issues where possible in the `./src` directory.
source: packages/@biomejs/biome/README.pt-BR.md#_snippet_3

language: shell
code:
```
```shell
# executar formatação, lint, etc. e aplicar as sugestões seguras
npx @biomejs/biome check --write ./src
```
```

---

title: Running Format, Lint, and Applying Safe Fixes
description: Demonstrates how to run formatting and linting, and apply safe fixes using the `Biome` CLI. The command `npx @biomejs/biome check --write ./src` formats, lints, and applies safe fixes to all files in the `./src` directory, overwriting the original files.
source: packages/@biomejs/biome/README.zh-CN.md#_snippet_3

language: shell
code:
```
# 运行格式化，Lint 等，并应用安全的建议
npx @biomejs/biome check --write ./src
```

---

title: Checking Files in a CI Environment
description: Demonstrates how to check files for formatting and linting errors in a CI environment using the `Biome` CLI. The command `npx @biomejs/biome ci ./src` checks all files in the `./src` directory and exits with a non-zero code if any issues are found, making it suitable for CI pipelines.
source: packages/@biomejs/biome/README.zh-CN.md#_snippet_4

language: shell
code:
```
# 在 CI 环境中检查所有文件是否符合格式，Lint 等
npx @biomejs/biome ci ./src
```

---

title: Changing Import Assertion Grammar
description: Illustrates the change in import assertion grammar from `assert {}` to `with {}`. This modification aligns with the newer import attribute assertion syntax.
source: ROME_CHANGELOG.md#_snippet_1

language: diff
code:
```
```diff
- import "module" assert {}
+ import "module" with {}
```
```

---

title: Formatting Json Files
description: Demonstrates the addition of formatting support for `JSON` files.
source: ROME_CHANGELOG.md#_snippet_0

language: txt
code:
```
- Add support to format JSON files.
```

---

title: Parsing Typescript's Resolution Mode In Import Types
description: Adds support for parsing typescript's `resolution-mode` in Import Types, allowing to specify how modules should be resolved.
source: CHANGELOG_v1.md#_snippet_0

language: ts
code:
```
export type Fs = typeof import('fs', { with: { 'resolution-mode': 'import' } });
export type TypeFromRequire =
  import("pkg", { with: { "resolution-mode": "require" } }).TypeFromRequire;
export type TypeFromImport =
  import("pkg", { with: { "resolution-mode": "import" } }).TypeFromImport;
```

---

title: Adding New Linter Rule Use Guard For In
description: Introduces the `useGuardForIn` linter rule to enforce proper type guards when iterating over objects using `for...in` loops, improving type safety.
source: CHANGELOG_v1.md#_snippet_1

language: txt
code:
```
Add [useGuardForIn](https://biomejs.dev/linter/rules/use-guard-for-in/). Contributed by @fireairforce
```

---

title: Adding New Linter Rule No Document Cookie
description: Introduces the `noDocumentCookie` linter rule to prevent direct access to `document.cookie`, encouraging safer cookie management practices.
source: CHANGELOG_v1.md#_snippet_2

language: txt
code:
```
Add [noDocumentCookie](https://biomejs.dev/linter/rules/no-document-cookie/). Contributed by @tunamaguro
```

---

title: Adding New Linter Rule No Duplicate Properties
description: Introduces the `noDuplicateProperties` linter rule to detect duplicate properties in object literals, enhancing code maintainability.
source: CHANGELOG_v1.md#_snippet_3

language: txt
code:
```
Add [noDuplicateProperties](https://biomejs.dev/linter/rules/no-duplicate-properties/). Contributed by @togami2864
```

---

title: Adding New Linter Rule No Useless String Raw
description: Adds the `noUselessStringRaw` linter rule that flags redundant `String.raw` calls where the raw string literal is already available, simplifying code.
source: CHANGELOG_v1.md#_snippet_4

language: txt
code:
```
Add [noUselessStringRaw](https://biomejs.dev/linter/rules/no-useless-string-raw/). Contributed by @fireairforce
```

---

title: Adding New Linter Rule Use At Index
description: Adds the `useAtIndex` linter rule which recommends using `Array.at()` method instead of bracket notation when accessing array elements.
source: CHANGELOG_v1.md#_snippet_5

language: txt
code:
```
Add [useAtIndex](https://biomejs.dev/linter/rules/use-at-index/). Contributed by @GunseiKPaseri
```

---

title: Adding New Linter Rule Use Collapsed If (Nursery)
description: Adds the `nursery/useCollapsedIf` linter rule, which suggests collapsing nested `if` statements into a single `if` statement for improved readability.
source: CHANGELOG_v1.md#_snippet_6

language: txt
code:
```
Add [nursery/useCollapsedIf](https://biomejs.dev/linter/rules/use-collapsed-if/). Contributed by @siketyan
```

---

title: Adding New Linter Rule Use Exports Last
description: Adds the `useExportsLast` linter rule that enforces placing all exports at the end of a module, improving code organization.
source: CHANGELOG_v1.md#_snippet_7

language: txt
code:
```
Add [useExportsLast](https://biomejs.dev/linter/rules/use-exports-last/). Contributed by @tommymorgan
```

---

title: Fixing No Void Type Return Rule
description: Fixes the `noVoidTypeReturn` rule to correctly allow `void` expressions in return positions, accepting scenarios where a function returns `void 0`.
source: CHANGELOG_v1.md#_snippet_8

language: ts
code:
```
function f(): void {
  return void 0;
}
```

---

title: Parsing Emoji In CSS Identifiers
description: The CSS parser now accepts a broader range of emoji characters in identifiers, aligning with browser behavior.
source: CHANGELOG_v1.md#_snippet_9

language: css
code:
```
p {
  --✨-color: red;
  color: var(--✨-color);
}
```

---

title: Searching with GritQL by Matching Async Functions Or Methods
description: GritQL queries that match functions or methods will now match async functions or methods as well, and explains how to avoid this behavior.
source: CHANGELOG_v1.md#_snippet_10

language: grit
code:
```
$async function foo() {} where $async <: .
```

---

title: Adding Nursery No Template Curly In String
description: Adds the `noTemplateCurlyInString` rule, which flags potential errors when template curly braces are used in regular strings, potentially indicating a typo or intended template literal.
source: CHANGELOG_v1.md#_snippet_11

language: txt
code:
```
Add [noTemplateCurlyInString](https://biomejs.dev/linter/rules/no-template-curly-in-string/). Contributed by @fireairforce
```

---

title: Adding Nursery No Octal Escape
description: Adds the `noOctalEscape` rule, which prevents the usage of octal escape sequences in strings as they're deprecated.
source: CHANGELOG_v1.md#_snippet_12

language: txt
code:
```
Add [noOctalEscape](https://biomejs.dev/linter/rules/no-octal-escape/). Contributed by @fireairforce
```

---

title: No Misleading Character Class Reporting Issues Outside Character Classes
description: The `noMisleadingCharacterClass` rule now avoids reporting issues outside of character classes, ensuring more accurate diagnostics.
source: CHANGELOG_v1.md#_snippet_13

language: js
code:
```
/[a-z][U+1F44D]/;
```

---

title: No Undeclared Dependencies Ignoring Nodejs Modules
description: The `noUndeclaredDependencies` rule now excludes Node.js builtin modules from being reported as undeclared dependencies, improving accuracy.
source: CHANGELOG_v1.md#_snippet_14

language: js
code:
```
import * as fs from "fs";
```

---

title: No Unused Function Parameters Ignoring Object Pattern With Rest Parameter
description: The `noUnusedFunctionParameters` rule now accurately identifies unused parameters even when they're part of an object pattern with a rest parameter.
source: CHANGELOG_v1.md#_snippet_15

language: js
code:
```
function f({ a, ...rest }) {
  return rest;
}
```

---

title: Use Button Type Accepting Dynamically Created Buttons With Valid Type
description: The `useButtonType` rule now accurately identifies and skips dynamically created buttons that already have a valid type, reducing false positives.
source: CHANGELOG_v1.md#_snippet_16

language: js
code:
```
React.createElement("button", { type: "button" }, "foo")
```

---

title: Use Semantic Elements Ignoring Elements With Img Role
description: The `useSemanticElements` rule now excludes elements with the `img` role, as they are often used for grouping images or creating images from other elements as recommended by MDN.
source: CHANGELOG_v1.md#_snippet_17

language: jsx
code:
```
<div role="img" aria-label="That cat is so cute">
  <p>&#x1F408; &#x1F602;</p>
</div>
```

---

title: No Unknown Function Correctly Handling Calc Size Function
description: The `noUnknownFunction` rule now correctly recognizes and handles the `calc-size` function, avoiding false positives.
source: CHANGELOG_v1.md#_snippet_18

language: css
code:
```
.a { height: calc-size(0px); }
```

---

title: Adding Nursery No Missing Var Function
description: Adds the `nursery/noMissingVarFunction` rule which identifies cases where the `var()` function is used without a corresponding CSS variable, potentially leading to unexpected behavior.
source: CHANGELOG_v1.md#_snippet_19

language: txt
code:
```
Add [nursery/noMissingVarFunction](https://biomejs.dev/linter/rules/no-missing-var-function). Contributed by @michellocana
```

---

title: Adding Nursery Use Component Export Only Modules
description: Adds the `nursery/useComponentExportOnlyModules` rule to enforce code styling compatible with React Refresh in React projects, ensuring that modules only export React components.
source: CHANGELOG_v1.md#_snippet_20

language: txt
code:
```
Add [nursery/useComponentExportOnlyModules](https://biomejs.dev/linter/rules/use-component-export-only-modules). Use this rule in React projects to enforce a code styling that fits React Refresh. Contributed by @GunseiKPaseri
```

---

title: No Label Without Control Accepting JSX Expression As Label Value
description: The `noLabelWithoutControl` rule now accepts JSX expressions as label values, preventing false positives in React components.
source: CHANGELOG_v1.md#_snippet_21

language: txt
code:
```
[noLabelWithoutControl](https://biomejs.dev/linter/rules/no-label-without-control/) now accept JSX expression as label value ([#3875](https://github.com/biomejs/biome/issues/3875)). Contributed by @Conaclos
```

---

title: Use Filenaming Convention Not Suggesting Names With Disallowed Case
description: The `useFilenamingConvention` rule now accurately avoids suggesting names with a disallowed case, preventing incorrect recommendations.
source: CHANGELOG_v1.md#_snippet_22

language: txt
code:
```
[useFilenamingConvention](https://biomejs.dev/linter/rules/use-filenaming-convention) no longer suggests names with a disallowed case ([#3952](https://github.com/biomejs/biome/issues/3952)). Contributed by @Conaclos
```

---

title: Use Filenaming Convention Recognizing File Names Starting With ASCII Digits As Lowercase
description: The `useFilenamingConvention` rule now correctly classifies file names starting with ASCII digits as lowercase, ensuring accurate categorization.
source: CHANGELOG_v1.md#_snippet_23

language: txt
code:
```
[useFilenamingConvention](https://biomejs.dev/linter/rules/use-filenaming-convention) now recognizes file names starting with ASCII digits as lowercase ([#3952](https://github.com/biomejs/biome/issues/3952)).
```

---

title: Use Filenaming Convention Applying Formats To File Extensions
description: The `useFilenamingConvention` rule now correctly applies the configured formats to the file extensions, ensuring consistent naming across all file types.
source: CHANGELOG_v1.md#_snippet_24

language: txt
code:
```
[useFilenamingConvention](https://biomejs.dev/linter/rules/use-filenaming-convention) now applies the configured formats to the file extensions ([#3650](https://github.com/biomejs/biome/discussions/3650)). Contributed by @Conaclos
```

---

title: Reporting Script Files With Strict Mode Directives
description: The `useStrictMode` rule now identifies and reports script files that include some directives but lack the `use strict` directive, ensuring consistent strict mode usage.
source: CHANGELOG_v1.md#_snippet_25

language: txt
code:
```
[useStrictMode](https://biomejs.dev/linter/rules/use-strict-mode/) now reports Script files with some directives, but without the `use strict` directive. Contributed by @Conaclos
```

---

title: Accepting Unicode Identifiers In CSS
description: The CSS parser has been updated to accept characters U+FFDCF and U+FFFD in identifiers, broadening support for Unicode in CSS.
source: CHANGELOG_v1.md#_snippet_26

language: txt
code:
```
The CSS parser now accepts the characters U+FFDCF and U+FFFD in identifiers. Contributed by @Conaclos
```

---

title: Adding Nursery No Process Env
description: Adds the `nursery/no-process-env` rule, designed to disallow the usage of `process.env` in codebases where environment variables should be accessed through a more controlled or type-safe mechanism.
source: CHANGELOG_v1.md#_snippet_27

language: txt
code:
```
Add [nursery/noProcessEnv](https://biomejs.dev/linter/rules/no-process-env/). Contributed by @unvalley
```

---

title: No Undeclared Dependencies Ignoring Certain Imports
description: The `noUndeclaredDependencies` rule is now smarter, ignoring `@/` imports and correctly recognizing type imports from Definitely Typed and `bun` imports, reducing false positives.
source: CHANGELOG_v1.md#_snippet_28

language: txt
code:
```
[noUndeclaredDependencies](https://biomejs.dev/linter/rules/no-undeclared-dependencies/) now ignores `@/` imports and recognizes type imports from Definitely Typed and `bun` imports. Contributed by @Conaclos
```

---

title: New Linter Rule No Common Js (Nursery)
description: Introduces the `nursery/noCommonJs` lint rule to identify and flag the use of CommonJS `require` and `module.exports` in JavaScript/TypeScript files, promoting the use of ES modules.
source: CHANGELOG_v1.md#_snippet_30

language: txt
code:
```
Add [nursery/noCommonJs](https://biomejs.dev/linter/rules/no-common-js/). Contributed by @minht11
```

---

title: Adding Nursery No Duplicate Custom Properties
description: The `nursery/noDuplicateCustomProperties` rule is added to detect and report duplicate custom properties within CSS files, enhancing CSS maintainability.
source: CHANGELOG_v1.md#_snippet_31

language: txt
code:
```
Add [nursery/noDuplicateCustomProperties](https://biomejs.dev/linter/rules/no-duplicate-custom-properties/). Contributed by @chansuke
```

---

title: Add Nursery No Enum
description: Introduces the `nursery/noEnum` lint rule, which warns against the usage of `enum` in TypeScript code, promoting the use of union types or constant objects instead.
source: CHANGELOG_v1.md#_snippet_32

language: txt
code:
```
Add [nursery/noEnum](https://biomejs.dev/linter/rules/no-enum/). Contributed by @nickfla1
```

---

title: New Linter Rule No Dynamic Namespace Import Access (Nursery)
description: Introduces the `nursery/noDynamicNamespaceImportAccess` lint rule, designed to prevent dynamic access to properties on namespace imports, which can lead to unpredictable code execution.
source: CHANGELOG_v1.md#_snippet_33

language: txt
code:
```
Add [nursery/noDynamicNamespaceImportAccess](https://biomejs.dev/linter/no-dynamic-namespace-import-access/). Contributed by @minht11
```

---

title: Adding Nursery No Irregular Whitespace
description: Adds the `nursery/noIrregularWhitespace` rule, aimed at detecting and flagging the use of irregular whitespace characters in code files, ensuring better code readability and consistency.
source: CHANGELOG_v1.md#_snippet_34

language: txt
code:
```
Add [nursery/noIrregularWhitespace](https://biomejs.dev/linter/rules/no-irregular-whitespace). Contributed by @michellocana
```

---

title: Adding Nursery No Restricted Types
description: Introduces a new linting rule, `nursery/no-restricted-types`, which allows developers to specify a list of types that should not be used, enhancing code maintainability and preventing the usage of deprecated or unsafe types.
source: CHANGELOG_v1.md#_snippet_35

language: txt
code:
```
Add [nursery/noRestrictedTypes](https://biomejs.dev/linter/no-restricted-types/). Contributed by @minht11
```

---

title: New Linter Rule No Secrets (Nursery)
description: Adds the `nursery/no-secrets` lint rule, designed to automatically detect and prevent the accidental commit of secrets and API keys directly within code, enhancing security.
source: CHANGELOG_v1.md#_snippet_36

language: txt
code:
```
Add [nursery/noSecrets](https://biomejs.dev/linter/rules/no-secrets/). Contributed by @SaadBazaz
```

---

title: New Linter Rule No Useless Escape In Regex (Nursery)
description: Adds the `nursery/noUselessEscapeInRegex` lint rule, to find and flag useless escape sequences within regular expressions, improving their readability and maintainability.
source: CHANGELOG_v1.md#_snippet_37

language: txt
code:
```
Add [nursery/noUselessEscapeInRegex](https://biomejs.dev/linter/rules/no-useless-escape-in-regex/). Contributed by @Conaclos
```

---

title: Adding New Linter Rule No Value At Rule
description: Adds the `nursery/noValueAtRule` lint rule, intended to disallow the use of value at-rules in CSS, steering developers towards more modern or maintainable approaches.
source: CHANGELOG_v1.md#_snippet_38

language: txt
code:
```
Add [nursery/noValueAtRule](https://biomejs.dev/linter/rules/no-value-at-rule/). Contributed by @rishabh3112
```

---

title: Add Nursery Use Aria Props Supported By Role
description: The `nursery/use-aria-props-supported-by-role` rule is added, aiming to enforce the use of only ARIA properties supported by a given role, increasing accessibility compliance.
source: CHANGELOG_v1.md#_snippet_39

language: txt
code:
```
Add [nursery/useAriaPropsSupportedByRole](https://biomejs.dev/linter/rules/use-aria-props-supported-by-role/). Contributed by @ryo-ebata
```

---

title: Adding Nursery Use Consistent Member Accessibility
description: Adds the `nursery/useConsistentMemberAccessibility` rule, designed to encourage consistent specification of accessibility modifiers (public, private, protected) on class members, improving code clarity.
source: CHANGELOG_v1.md#_snippet_40

language: txt
code:
```
Add [nursery/useConsistentMemberAccessibility](https://biomejs.dev/linter/rules/use-consistent-member-accessibility/). Contributed by @seitarof
```

---

title: New Linter Rule Use Strict Mode (Nursery)
description: The new linter rule `nursery/useStrictMode` is added, encouraging the use of strict mode in JavaScript files to enhance code safety and prevent common errors.
source: CHANGELOG_v1.md#_snippet_41

language: txt
code:
```
Add [nursery/useStrictMode](https://biomejs.dev/linter/rules/use-strict-mode/). Contributed by @ematipico
```

---

title: Adding Nursery Use Trim Start End
description: The `nursery/useTrimStartEnd` rule is added to encourage developers to use `trimStart` and `trimEnd` instead of the deprecated `trimLeft` and `trimRight` methods, aligning with modern JavaScript standards.
source: CHANGELOG_v1.md#_snippet_42

language: txt
code:
```
Add [nursery/useTrimStartEnd](https://biomejs.dev/linter/rules/use-trim-start-end/). Contributed by @chansuke
```

---

title: Adding Nursery No Irregular Whitespace
description: Adds the `nursery/noIrregularWhitespace` rule, aimed at detecting and flagging the use of irregular whitespace characters in code files, ensuring better code readability and consistency.
source: CHANGELOG_v1.md#_snippet_43

language: txt
code:
```
Add [nursery/noIrregularWhitespace](https://biomejs.dev/linter/rules/no-irreguluar-whitespace/). Contributed by @DerTimonius
```

---

title: Allowing Blank Targets By Specifying Allowed Domains
description: The `noBlankTarget` rule is enhanced to allow specifying an array of allowed domains, providing greater control over external links considered safe.
source: CHANGELOG_v1.md#_snippet_44

language: json
code:
```
"linter": {
    "rules": {
      "a11y": {
        "noBlankTarget": {
        "level": "error",
          "options": {
             "allowDomains": ["example.com", "example.org"]
            }
          }
        }
      }
    }
  
```

---

title: No Console Accepting Option That Specifies Some Allowed Calls On Console
description: The `noConsole` rule is enhanced to allow specifying an option that accepts some allowed calls on console, to allow selectively ignoring calls for `console.warn` or `console.error` while flagging the rest.
source: CHANGELOG_v1.md#_snippet_45

language: txt
code:
```
[noConsole](https://biomejs.dev/linter/rules/no-console/) now accepts an option that specifies some allowed calls on `console`. Contributed by @Conaclos
```

---

title: No Double Equals Enhancements
description: Enhances the `noDoubleEquals` rule by adding an `ignoreNull` option to disable reporting loose comparisons against `null`.
source: CHANGELOG_v1.md#_snippet_46

language: txt
code:
```
Add an `ignoreNull` option for [noDoubleEquals](https://biomejs.dev/linter/rules/no-double-equals/).
```

---

title: Allowing Configuring Conventions For Readonly Index Signatures
description: Enhances the `useNamingConvention` rule to allow configuring naming conventions specifically for readonly index signatures, improving code consistency.
source: CHANGELOG_v1.md#_snippet_47

language: txt
code:
```
[useNamingConvention](https://biomejs.dev/linter/rules/use-naming-convention/) now allows configuring conventions for readonly index signatures.
```

---

title: The JSON Parser Now Allows Comments In Files
description: The JSON parser now correctly allows comments in `turbo.json` and `jest.config.json`, and also in `.json` files under `.vscode` and `.zed` directories.
source: CHANGELOG_v1.md#_snippet_48

language: txt
code:
```
The JSON parser now allows comments in `turbo.json` and `jest.config.json`. Contributed by @Netail and @Conaclos
```

---

title: Parsing Emoji In CSS Identifiers
description: The CSS parser has been updated to accept emoji in identifiers, aligning with browser behavior.
source: CHANGELOG_v1.md#_snippet_49

language: css
code:
```
p {
  --[U+1F954]-color: red;
  color: var(--[U+1F954]-color);
}
```

---

title: Formatting Files
description: Demonstrates how to format files using the Biome CLI.  The `format` command with the `--write` flag applies formatting changes directly to the files in the specified `./src` directory.
source: README.md#_snippet_1

language: shell
code:
```
# format files
npx @biomejs/biome format --write ./src
```

---

title: Linting Files
description: Demonstrates how to lint files and apply safe fixes using the Biome CLI. The `lint` command with the `--write` flag applies the safe fixes directly to the files in the specified `./src` directory.
source: README.md#_snippet_2

language: shell
code:
```
# lint files and apply the safe fixes
npx @biomejs/biome lint --write ./src
```

---

title: Running Checks and Applying Safe Fixes
description: Demonstrates how to run format, lint, and other checks, and apply safe fixes using the Biome CLI. The `check` command with the `--write` flag applies the safe fixes directly to the files in the specified `./src` directory.
source: README.md#_snippet_3

language: shell
code:
```
# run format, lint, etc. and apply the safe fixes
npx @biomejs/biome check --write ./src
```

---

title: Checking Files in CI Environments
description: Demonstrates how to check all files against formatting, linting, and other checks in CI environments using the Biome CLI.  The `ci` command is used to ensure code quality and consistency in continuous integration workflows.
source: README.md#_snippet_4

language: shell
code:
```
# check all files against format, lint, etc. in CI environments
npx @biomejs/biome ci ./src
```

---

title: Debugging a Crash
description: Illustrates how to minimize the input that caused a crash using `cargo fuzz tmin`. This command helps in creating a smaller, more manageable test case for debugging.
source: fuzz/README.md#_snippet_1

language: bash
code:
```
cargo fuzz tmin --strip-dead-code -s none name_of_fuzzer artifacts/name_of_fuzzer/crash-...
```

---

title: Updating Rast Snapshots
description: Demonstrates how to update the `.rast` snapshots for testing the JavaScript parser. This command sets the `UPDATE_EXPECT` environment variable and runs the test suite specifically for the `biome_js_parser` crate, ensuring that the snapshots are updated based on the current code.
source: crates/biome_js_parser/README.md#_snippet_0

language: bash
code:
```
UPDATE_EXPECT=1 cargo test -p biome_js_parser
```

---

title: Using Deserializable Derive Macro - Rust
description: Illustrates how to use the `Deserializable` derive macro from `biome_deserialize_macros` to generate an implementation of the `Deserializable` trait for structs. The macro simplifies the process of making custom types deserializable by automatically generating the necessary code, reducing boilerplate. The example shows a simple struct `MyRuleOptions` with fields of different types.
source: crates/biome_deserialize/README.md#_snippet_1

language: rust
code:
```
#[derive(Clone, Debug, Default, Deserializable)]
pub struct MyRuleOptions {
    behavior: Behavior,
    threshold: u8,
    behavior_exceptions: Vec<String>
}
```

---

title: Deserializing a Union
description: Demonstrates how to implement the `Deserializable` trait for a `Union` type that can be either a boolean or a string. It inspects the type of the `DeserializableValue` to determine which deserializer to use.
source: crates/biome_deserialize/README.md#_snippet_0

language: rust
code:
```
use biome_deserialize::{DeserializationDiagnostic, Deserializable, DeserializationContext, DeserializableValue, DeserializationVisitor, Text, DeserializableTypes};
use biome_rowan::TextRange;

#[derive(Debug, Eq, PartialEq)]
enum Union {
    Bool(bool),
    Str(String),
}

impl Deserializable for Union {
    fn deserialize(
        ctx: &mut impl DeserializationContext,
        value: &impl DeserializableValue,
        name: &str,
    ) -> Option<Self> {
        if value.visitable_type()? == DeserializableType::Bool {
            biome_deserialize::Deserializable::deserialize(ctx, value, name)
                .map(Self::Bool)
        } else {
            biome_deserialize::Deserializable::deserialize(ctx, value, name)
                .map(Self::Str)
        }
    }
}
```

---

title: Deserializing a Union - Usage
description: Shows how to use the `deserialize_from_json_str` function to deserialize a JSON string or boolean into the `Union` type. It asserts that the deserialization is successful and that the resulting value is correct.
source: crates/biome_deserialize/README.md#_snippet_1

language: rust
code:
```
use biome_deserialize::json::deserialize_from_json_str;
use biome_json_parser::JsonParserOptions;

let source = r#" "string" "#;
let deserialized = deserialize_from_json_str::<Union>(&source, JsonParserOptions::default(), "path/to.json");
assert!(!deserialized.has_errors());
assert_eq!(deserialized.into_deserialized(), Some(Union::Str("string".to_string())));

let source = "true";
let deserialized = deserialize_from_json_str::<Union>(&source, JsonParserOptions::default(), "path/to.json");
assert!(!deserialized.has_errors());
assert_eq!(deserialized.into_deserialized(), Some(Union::Bool(true)));
```

---

title: Implementing Deserializable for an Enumeration of Values
description: Demonstrates how to implement the `Deserializable` trait for an enumeration (`Variant`) with specific string values (`A`, `B`). The implementation reuses the `String` type's deserialization and reports a diagnostic if an unknown variant is encountered.
source: crates/biome_deserialize/README.md#_snippet_3

language: rust
code:
```
use biome_deserialize::{Deserializable, DeserializationContext, DeserializableValue, DeserializationDiagnostic};

#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash, Ord, PartialOrd)]
pub enum Variant { A, B }

impl Deserializable for Variant {
    fn deserialize(
        ctx: &mut impl DeserializationContext,
        value: &impl DeserializableValue,
        name: &str,
    ) -> Option<Self> {
        match String::deserialize(ctx, value, name)? {
            "A" => Some(Variant::A),
            "B" => Some(Variant::B),
            unknown_variant => {
                const ALLOWED_VARIANTS: &[&str] = &["A", "B"];
                ctx.report(DeserializationDiagnostic::new_unknown_value(
                    unknown_variant,
                    value.range(),
                    ALLOWED_VARIANTS,
                ));
                None
            }
        }
    }
}
```

---

title: Naming Tests Based on File Names
description: Illustrates how the test name is derived from the file name by converting it to snake case. The generated test function includes the full paths to the test file and the expected file, which are then passed to the `run_test` function.
source: crates/tests_macros/README.md#_snippet_1

language: rust
code:
```
#[test]
pub fn somefilename()
{
    let test_file = "<crate's cargo.toml full path>/tests/sometest.txt";
    let test_expected_file = "<crate's cargo.toml full path>/tests/sometest.expected.txt";
    run_test(test_file, test_expected_file);
}
```

---

title: Running Tests with Cargo
description: Shows various `cargo test` commands for running tests at different scopes. The commands demonstrate how to run all tests, tests for a specific crate, tests within a module, or a single test function.
source: crates/tests_macros/README.md#_snippet_2

language: text
code:
```
> cargo test                                            // all tests in all crates
> cargo test -p crate-name                              // all tests of one crate
> cargo test -p crate-name -- some_mod::                // all tests of one crate and one module
> cargo test -p crate-name -- some_mod::somefilename    // just one test
```

---

title: Using useImperativeHandle React Hook
description: Illustrates the usage of the `useImperativeHandle` hook in React components. It demonstrates how to customize the instance value that is exposed to parent components when using `ref` forwarding, with varying dependency arrays.
source: crates/biome_js_formatter/report.md#_snippet_1

language: javascript
code:
```
function Component1() {
  useImperativeHandle(
    ref,
    () => {
      /* Function body */
    },
    [],
  );
  useImperativeHandle(
    ref,
    () => {
      /* Function body */
    },
    [props.value],
  );
  useImperativeHandle(
    ref,
    () => {
      /* Function body */
    },
    [
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
    ],
  );
}

function Component2() {
  React.useImperativeHandle(
    ref,
    () => {
      /* Function body */
    },
    [],
  );
  React.useImperativeHandle(
    ref,
    () => {
      /* Function body */
    },
    [props.value],
  );
  React.useImperativeHandle(
    ref,
    () => {
      /* Function body */
    },
    [
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
    ],
  );
}

function Component3() {
  useImperativeHandle(
    ref,
    () => {
      /* Function body */
    },
    [],
  );
}
```

---

title: Commenting out statements
description: Demonstrates how to comment out entire statements using block and line comments. It shows different ways comments can be placed and how they affect the execution of the code, particularly focusing on comments within and around expressions.
source: crates/biome_js_formatter/report.md#_snippet_0

language: diff
code:
```
+a; /* a */ /* c */ // b
+
+foo; // first // second // third
+
+function x() {} // first // second
+
 a =
+  b + // 1 // 2
+  c + // 3 // 4
+  d /* 6 */ + // 5
   e; // 7
```

---

title: Exporting with Comments
description: Illustrates the usage of comments in export statements. It showcases how comments can be placed after the `export` keyword, within the curly braces of named exports, and before/after identifiers being exported, including aliased exports with `as`.
source: crates/biome_js_formatter/report.md#_snippet_1

language: diff
code:
```
 export //comment
+{};
 
 export /* comment */ {};
 
 const foo = "";
 export {
   foo, // comment
 };
 
 const bar = "";
 export {
   // comment
   bar,
 };
 
 const fooo = "";
 const barr = "";
 export {
   fooo, // comment
   barr, // comment
 };
 
 const foooo = "";
 const barrr = "";
 export {
   foooo,
   // comment
   barrr as baz,
 } from "foo";
 
 const fooooo = "";
 const barrrr = "";
 export {
   fooooo,
   // comment
   barrrr as bazz,
 };
```

---

title: Commenting out HTML-like code
description: Demonstrates how HTML-like comments can be used to comment out code within JavaScript. It shows a simple example of commenting out an `alert` statement using `<!--` and `-->`.
source: crates/biome_js_formatter/report.md#_snippet_2

language: diff
code:
```
 <!--
-alert(1); 
+alert(1)
 -->
```

---

title: Commenting multiple statements
description: Illustrates the usage of multiple comments on the same line, both using block comments. It demonstrates how these comments can be placed before, after, and within statements, and how they interact with the code.
source: crates/biome_js_formatter/report.md#_snippet_3

language: diff
code:
```
 /*========= All on same line =========*/
 a;
 /*1*/ /*2*/ /*3*/
 b;
 
 a; /*1*/ /*2*/ /*3*/
 b;
 
 a;
 /*1*/ /*2*/ /*3*/ b;
 
 a;
 /*
 1*/ /*2*/ /*3
  */
 b;
 
 a; /*
 1*/ /*2*/ /*3
  */
 b;
 
-a;
-/*
+a; /*
 1*/ /*2*/ /*3
- */ b;
+ */
+b;
 
 /*========= First two on same line =========*/
 a;
 /*1*/ /*2*/
 /*3*/
 b;
 
 a; /*1*/ /*2*/
 /*3*/
 b;
 
 a;
 /*1*/ /*2*/
 /*3*/ b;
 
 a;
 /*
 1*/ /*2*/
 /*3
  */
 b;
 
 a; /*
 1*/ /*2*/
 /*3
  */
 b;
 
 a; /*
 1*/ /*2*/
 /*3
  */ b;
 
 /*========= Last two on same line =========*/
 a;
 /*1*/
 /*2*/ /*3*/
 b;
 
 a; /*1*/
 /*2*/ /*3*/
 b;
 
 a;
 /*1*/
 /*2*/ /*3*/ b;
 
 a;
 /*
 1*/
 /*2*/ /*3
  */
 b;
 
 a; /*
 1*/
 /*2*/ /*3
  */
 b;
 
 a; /*
 1*/
 /*2*/ /*3
  */ b;
```

---

title: Formatting Return Statements - Javascript
description: Demonstrates how comments are formatted within various JavaScript return statements, including those with unary, numeric literals, logical, and binary expressions. Illustrates how comments are handled in conditional expressions, function calls, and member expressions. Shows how the formatter handles comments in sequence expressions, tagged templates, and multiline blocks.
source: crates/biome_js_formatter/report.md#_snippet_0

language: javascript
code:
```
function jsx() {
  return (
    // Comment
    <div />
  );
}

function unary() {
  return (
    // Comment
    !!x
  );
}

function numericLiteralNoParen() {
  return 1337; // Comment
}

function logical() {
  return (
    // Reason for 42
    42 && 84
  );
}

function binary() {
  return (
    // Reason for 42
    42 * 84
  );
}

function binaryInBinaryLeft() {
  return (
    // Reason for 42
    42 * 84 + 2
  );
}

function binaryInBinaryRight() {
  return (
    // Reason for 42
    42 + 84 * 2
  );
}

function conditional() {
  return (
    // Reason for 42
    42 ? 1 : 2
  );
}

function binaryInConditional() {
  return (
    // Reason for 42
    42 * 3 ? 1 : 2
  );
}

function call() {
  return (
    // Reason for a
    a()
  );
}

function memberInside() {
  return (
    // Reason for a.b
    a.b.c
  );
}

function memberOutside() {
  return (
    // Reason for a
    a.b.c
  );
}

function memberInAndOutWithCalls() {
  return (
    // Reason for a
    aFunction
      .b()
      .c.d()
  );
}

function excessiveEverything() {
  return (
    // Reason for stuff
    a.b() * 3 + 4 ? ((a`hi`, 1) ? 1 : 1) : 1
  );
}

// See https://github.com/prettier/prettier/issues/2392
// function sequenceExpression() {
//   return (
//     // Reason for a
//     a
//   ), b
// }

function sequenceExpressionInside() {
  return (
    // Reason for a
    a, b
  );
}

function taggedTemplate() {
  return (
    // Reason for a
    a`b`
  );
}

function inlineComment() {
  return /* hi */ 42 || 42;
}

function multilineBlockSameLine() {
  return (
    /**
     * @type {string}
     */ "result"
  );
}

function multilineBlockNextLine() {
  return (
    /**
     * @type {string}
     */
    "result"
  );
}

function multilineBlockSameLineJsx() {
  return (
    /**
     * JSX Same line
     */ <div></div>
  );
}

function multilineBlockNextLineJsx() {
  return (
    /**
     * JSX Next line
     */
    <div></div>
  );
}

function singleLineBlockSameLine() {
  return /** Result -> */ "result";
}

function singleLineBlockNextLine() {
  return (
    /** Result below */
    "result"
  );
}
```

---

title: Formatting Tagged Template Literals - Javascript
description: Demonstrates how tagged template literals are formatted, including the placement of comments before and within the tagged template. Illustrates the handling of comments when they appear before the backticks of a tagged template literal.
source: crates/biome_js_formatter/report.md#_snippet_1

language: javascript
code:
```
foo``; // comment

foo // comment
``;

foo // comment
`
`;

foo /* comment */`
`;

foo /* comment */`
`;
```

---

title: Formatting Conditional Expressions with Comments - Javascript
description: Demonstrates how conditional expressions with comments are formatted in JavaScript. Illustrates the formatting of comments within conditional expressions, including comments before the `?` and `:` operators, and within nested conditional expressions.
source: crates/biome_js_formatter/report.md#_snippet_2

language: javascript
code:
```
var inspect =
  4 === util.inspect.length
    ? // node <= 0.8.x
      function (v, colors) {
        return util.inspect(v, void 0, void 0, colors);
      }
    : // node > 0.8.x
      function (v, colors) {
        return util.inspect(v, { colors: colors });
      };

var inspect =
  4 === util.inspect.length
    ? // node <= 0.8.x
      function (v, colors) {
        return util.inspect(v, void 0, void 0, colors);
      }
    : // node > 0.8.x
      function (v, colors) {
        return util.inspect(v, { colors: colors });
      };

const extractTextPluginOptions = shouldUseRelativeAssetPaths
  ? // Making sure that the publicPath goes back to to build folder.
    { publicPath: Array(cssFilename.split("/").length).join("../") }
  : {};

const extractTextPluginOptions2 = shouldUseRelativeAssetPaths
  ? // Making sure that the publicPath goes back to to build folder.
    { publicPath: Array(cssFilename.split("/").length).join("../") }
  : {};

const extractTextPluginOptions3 = shouldUseRelativeAssetPaths // Making sure that the publicPath goes back to to build folder.
  ? { publicPath: Array(cssFilename.split("/").length).join("../") }
  : {};

const { configureStore } =
  process.env.NODE_ENV === "production"
    ? require("./configureProdStore") // a
    : require("./configureDevStore"); // b

test /* comment
  comment
       comment
 */
  ?
  foo
  :
  bar;

test
  ?
  /* comment
          comment
    comment
          comment
  */
  foo
  :
  bar;

test
  ?
  /* comment
        comment
        comment
        comment
     */
  foo
  :
  test
    ?
    /* comment
   comment
     comment */
    foo
    :
    bar;

test ? /* comment */ foo : bar;

test
  ?
  foo
  :
  /* comment
          comment
      comment
            comment
     */
  bar;

test
  ?
  foo
  :
  /* comment
          comment
      comment
            comment
       A newline will be added after this comment, unfortunately - but it can be removed manually, see next statement.
     */
  test
    ?
    foo
    :
    /* comment
   comment
     comment
    */
    bar;

// It is at least possible to delete the extra newline that was
// unfortunately added before the second condition above:
test
  ?
  foo
  :
  /* comment
          comment
      comment
            comment
     */
  test
    ?
    foo
    :
    /* comment
   comment
     comment
    */
    bar;

test ? foo : /* comment */ bar;

test
  ?
  test /* c
 c */
    ?
    foo
    :
    bar
  :
  bar;
```

---

title: Handling Ternary Operator Formatting
description: Demonstrates various cases of ternary operator formatting, including concatenated strings, function calls, and nested ternaries. Highlights potential areas for improved readability and consistency in conditional expressions.
source: crates/biome_js_formatter/report.md#_snippet_0

language: javascript
code:
```
// concatened string in consequent should be visually distinguishable from alternate
// ... or maybe this is okay, because the colon is enough?
const avatar = has_ordered
  ? "https://marmelab.com/posters/avatar/longer-word-that-breaks-consequent-" +
    numberOfCustomers +
    ".jpeg"
  : undefined;

// Similarly, in the alternate:
const redirectUrl = pathName
  ? pathName
  : nextPathName + nextSearch ||
    defaultAuthParams.afterLoginUrl.makeThisLongerSoItBreaks;

// And another, more pathological case of the above:
const isEmpty = (obj) =>
  obj instanceof Date
    ? false
    : obj === "" ||
      obj === null ||
      obj === undefined ||
      obj === somethingThatIsLonger ||
      shallowEqual(obj, {});

// Again, this case is a bit hard to distinguish the alternate.
const eventsFromOrders =
  orderIds && orders
    ? orderIds.map((id) => ({
        type: "order",
        date: orders[id].date,
        data: orders[id],
      }))
    : [];

// Kinda weird to have dedents to the level of "return" in a function.
function foo() {
  return !linkTo
    ? false
    : typeof linkTo === "function"
      ? linkTo(record, reference)
      : linkToRecord(rootPath, sourceId, linkTo_as_string);
}
function foo2() {
  return React.isValidElement(emptyText)
    ? React.cloneElement(emptyText)
    : emptyText === ""
      ? " " // em space, forces the display of an empty line of normal height
      : translate(emptyText, { _: emptyText });
}

// Function call ideally wouldnt break break
const matchingReferencesError = isMatchingReferencesError(matchingReferences)
  ? translate(matchingReferences.error, {
      _: matchingReferences.error,
    })
  : null;

// This one is kinda confusing any way you slice it...
const obj = {
  error:
    matchingReferencesError &&
    (!input.value ||
      (input.value && selectedReferencesDataStatus === REFERENCES_STATUS_EMPTY))
      ? translate("ra.input.references.all_missing", {
          _: "ra.input.references.all_missing",
        })
      : null,
};

// I think we should indent after the inner || on this, and do better wtih the parens around the &&
const obj2 = {
  warning:
    matchingReferencesError ||
    (input.value && selectedReferencesDataStatus !== REFERENCES_STATUS_READY)
      ? matchingReferencesError ||
        translate("ra.input.references.many_missing", {
          _: "ra.input.references.many_missing",
        })
      : null,
};

// The boolean conditions in the test should look cohesive.
const selectedReferencesDataStatus =
  !isEmpty(value) && typeof value === "string" && !pattern.test(value)
    ? getMessage(message, { pattern }, value, values)
    : undefined;

// Would be nice if these two nested ternaries didn't look like a single one.
resolveRedirectTo(
  redirectTo,
  basePath,
  payload
    ? payload.id || (payload.data ? payload.data.id : null)
    : requestPayload
      ? requestPayload.id
      : null,
  payload && payload.data
    ? payload.data
    : requestPayload && requestPayload.data
      ? requestPayload.data
      : null,
);
```

---

title: Using Await Expressions in Asynchronous Functions
description: Illustrates the use of `await using` with an escaped identifier in an asynchronous function. It demonstrates that the escaped identifier `\u0061b` is treated as a valid variable name when declaring a resource.
source: crates/biome_js_formatter/report.md#_snippet_0

language: diff
code:
```
async function f() {
-  await using ab = c;
+  await using \u0061b = c;
 }
```

---

title: Handling Comments with Await Using Declarations
description: Demonstrates the correct placement of comments around `await using` declarations within an asynchronous function. It covers various scenarios, including comments before, after, and between the keywords and identifiers.
source: crates/biome_js_formatter/report.md#_snippet_1

language: diff
code:
```
async function f() {
   {
-    /*0*/ await using /*1*/ /*2*/ b /*3*/ = /*4*/ f(); /*5*/
+    /*0*/ await using /*1*/ /*2*/ b /*3*/ = /*4*/ f() /*5*/;
   }
   {
     /*0*/ for (
       /*1*/ /*2*/ await using /*3*/ /*4*/ b /*5*/ =
           /*6*/ x /*7*/ /*8*/ /*9*/ /*10*/;
       ;
-
     );
   }
   {
     /*0*/ for (/*1*/ /*2*/ await using /*3*/ /*4*/ b /*5*/ of /*6*/ x /*7*/ /*8*/);
   }
   {
     /*0*/ for await (/*1*/ /*2*/ /*3*/ await using /*4*/ /*5*/ b /*6*/ of /*7*/ x /*8*/ /*9*/);
   }
 }
```

---

title: Using Escaped Identifiers in Using Declarations
description: Illustrates the use of an escaped unicode identifier `\u0061b` in a `using` declaration. This demonstrates that the formatter correctly handles unicode escapes in variable names.
source: crates/biome_js_formatter/report.md#_snippet_2

language: diff
code:
```
{
-  using ab = c;
+  using \u0061b = c;
 }
```

---

title: Fixing Blank Lines Between Export Specifiers (JavaScript)
description: Demonstrates removing blank lines between export specifiers in a JavaScript module. The code removes unnecessary newlines to improve code density and readability within the `export` statement.
source: crates/biome_js_formatter/report.md#_snippet_0

language: diff
code:
```
 export {
   // a
   foo1,
-
   // b
   bar1,
   baz1,
 } from "mod";
 
 const foo2 = 1;
 const bar2 = 1;
 const baz2 = 1;
 
 export {
   // a
   foo2,
-
   // b
   bar2,
   baz2,
 };
```

---

title: Correcting Parentheses in For-In Loops (JavaScript)
description: Illustrates the correction of parentheses usage within the initializer section of `for...in` loops in JavaScript. The diff showcases the necessary adjustments to ensure correct parsing and execution, particularly with complex expressions involving the `in` operator.
source: crates/biome_js_formatter/report.md#_snippet_1

language: diff
code:
```
 // https://github.com/babel/babel/blob/HEAD/packages/babel-generator/test/fixtures/parentheses/in-inside-for/input.js
 
 for (var a = (b in c) in {});
-for (var a = (1 || b in c) in {});
-for (var a = (1 + (2 || b in c)) in {});
-for (var a = (() => b in c) in {});
-for (var a = (1 || (() => b in c)) in {});
-for (var a = (() => {
+for (var a = 1 || (b in c) in {});
+for (var a = 1 + (2 || (b in c)) in {});
+for (var a = () => (b in c) in {});
+for (var a = 1 || (() => (b in c)) in {});
+for (var a = () => {
   b in c;
-}) in {});
-for (var a = ([b in c]) in {});
-for (var a = ({ b: b in c }) in {});
+} in {});
+for (var a = [(b in c)] in {});
+for (var a = { b: (b in c) } in {});
 // Meriyah can't parse
 // for (var a = (x = b in c) => {} in {});
-for (var a = (class extends (b in c) {}) in {});
-for (var a = (function (x = b in c) {}) in {});
+for (var a = class extends (b in c) {} in {});
+for (var a = function (x = (b in c)) {} in {});
```

---

title: Adjusting Parentheses in For Loops (JavaScript)
description: Illustrates the correct usage of parentheses within the conditional expression of `for` loops in JavaScript. The code adjustments ensure that expressions involving the `in` operator and arrow functions are correctly parsed, resolving potential syntax errors.
source: crates/biome_js_formatter/report.md#_snippet_2

language: diff
code:
```
 // https://github.com/babel/babel/blob/HEAD/packages/babel-generator/test/fixtures/parentheses/in-inside-for/input.js
 
 for (var a = (b in c); ; );
 for (var a = 1 || (b in c); ; );
 for (var a = 1 + (2 || (b in c)); ; );
 for (var a = () => (b in c); ; );
 for (var a = 1 || (() => (b in c)); ; );
 for (
   var a = () => {
-    (b in c);
+    b in c;
   };
   ;
-
 );
 for (var a = [(b in c)]; ; );
 for (var a = { b: (b in c) }; ; );
 for (var a = (x = (b in c)) => {}; ; );
 for (var a = class extends (b in c) {}; ; );
 for (var a = function (x = (b in c)) {}; ; );
 
 for (var a in b in c);
 for (var a in 1 || b in c);
 for (var a in 1 + (2 || b in c));
 for (var a in () => b in c);
 for (var a in 1 || (() => b in c));
 for (var a in () => {
   b in c;
 });
 for (var a in [b in c]);
 for (var a in { b: b in c });
 for (var a in (x = b in c) => {});
 for (var a in class extends (b in c) {});
 for (var a in function (x = b in c) {});
 
 for (; (a = b in c); );
 for (; (a = 1 || b in c); );
 for (; (a = 1 + (2 || b in c)); );
 for (; (a = () => b in c); );
 for (; (a = 1 || (() => b in c)); );
 for (
   ;
   (a = () => {
     b in c;
   });
-
 );
 for (; (a = [b in c]); );
 for (; (a = { b: b in c }); );
 for (; (a = (x = b in c) => {}); );
 for (; (a = class extends (b in c) {}); );
 for (; (a = function (x = b in c) {}); );
```

---

title: Handling Comments in Continue and Break Statements (JavaScript)
description: Demonstrates the correct placement and handling of comments following `continue` and `break` statements within `for` loops in JavaScript. The code ensures that comments are properly associated with their respective statements, maintaining code clarity and preventing unexpected behavior.
source: crates/biome_js_formatter/report.md#_snippet_3

language: diff
code:
```
 for (;;) continue;
 // comment
 
 for (;;) break;
 // comment
 
 for (const f of []) continue;
 // comment
 
 for (const f of []) break;
 // comment
 
 for (const f in {}) continue;
 // comment
 
 for (const f in {}) break;
 // comment
 
 for (;;) continue; // comment
 
 for (;;) break; // comment
 
 for (const f of []) continue; // comment
 
 for (const f of []) break; // comment
 
 for (const f in {}) continue; // comment
 
 for (const f in {}) break; // comment
 
 for (;;) continue; /* comment */
 
 for (;;) break; /* comment */
 
 for (const f of []) continue; /* comment */
 
 for (const f of []) break; /* comment */
 
 for (const f in {}) continue; /* comment */
 
 for (const f in {}) break; /* comment */
 
 for (;;) continue;
 /* comment */
 
 for (;;) break;
 /* comment */
 
 for (const f of []) continue;
 /* comment */
 
 for (const f of []) break;
 /* comment */
 
 for (const f in {}) continue;
 /* comment */
 
 for (const f in {}) break;
 /* comment */
 
-label1: for (;;) continue label1 /* comment */;
+label1: for (;;) continue label1; /* comment */
 
 label1: for (;;) continue label1;
 /* comment */
 
 label1: for (;;) continue label1; // comment
 
 label1: for (;;) continue label1;
 // comment
```

---

title: Adjusting Comments Within If-Else Expressions (JavaScript)
description: Demonstrates an adjustment in the placement of a comment within an `if-else` expression in JavaScript. The change removes the comment from within the `if` condition, clarifying the code and preventing potential parsing issues.
source: crates/biome_js_formatter/report.md#_snippet_4

language: diff
code:
```
 if (a === 0)
   doSomething(); // comment A1
 else if (a === 1)
   doSomethingElse(); // comment B1
 else if (a === 2) doSomethingElse(); // comment C1
 
 if (a === 0) doSomething(); /* comment A2 */
 else if (a === 1) doSomethingElse(); /* comment B2 */
 else if (a === 2) doSomethingElse(); /* comment C2 */
 
 if (a === 0)
   expr; // comment A3
 else if (a === 1)
   expr; // comment B3
 else if (a === 2) expr; // comment C3
 
 if (a === 0) expr; /* comment A4 */
 else if (a === 1) expr; /* comment B4 */
 else if (a === 2) expr; /* comment C4 */
 
 if (a === 0)
   looooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong; // comment A5
 else if (a === 1)
   looooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong; // comment B5
 else if (a === 2)
   looooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong; // comment C5
 
 function a() {
   if (a) return; /* comment 6a */
   else return 2;
 
   if (a) return 1; /* comment 6b */
   else return 2;
 
   if (a) throw e; /* comment 6d */
   else return 2;
 
   if (a) var a = 1; /* comment 6e */
   else return 2;
 
   if (a)
-    if (b /* comment 6f */);
+    if (b); /* comment 6f */
     else return 2;
 }
```

---

title: Removing Import Assertions
description: Illustrates how to remove import assertions from import statements. This simplifies the import syntax when assertions are not required.
source: crates/biome_js_formatter/report.md#_snippet_5

language: javascript
code:
```
export * as bar from "bar.json";
```

---

title: Removing Import Assertions from Imports and Exports
description: Illustrates how to remove import assertions from both import and export statements to simplify module dependencies.  The `assert {}` clauses are removed.
source: crates/biome_js_formatter/report.md#_snippet_6

language: javascript
code:
```
export * as foo from "foo.json";
export * as bar from "bar.json";
export * as baz from "baz.json" /* comment */;
```

language: javascript
code:
```
import * as foo from "foo.json";
import * as bar from "bar.json";
import * as baz from "baz.json" /* comment */;
```

---

title: Correcting Import Attributes Syntax
description: Shows how to correct the syntax for import attributes in JavaScript. The `/* assert */` and `/* with */` comments are placed inside the curly braces of the `with` and `assert` clauses.
source: crates/biome_js_formatter/report.md#_snippet_9

language: javascript
code:
```
import "./test.json" /* assert */ with { /* assert */ type: "json" };
import {} from "./test.json" /* assert */ with { /* assert */ type: "json" };
import "./test.json" /* with */ assert { /* with */ type: "json" };
import {} from "./test.json" /* with */ assert { /* with */ type: "json" };

export {} from "./test.json" /* assert */ with { /* assert */ type: "json" };
export {} from "./test.json" /* with */ assert { /* with */ type: "json" };

export * from "./test.json" /* assert */ with { /* assert */ type: "json" };
export * from "./test.json" /* with */ assert { /* with */ type: "json" };
```

---

title: Formatting Long Import Sources
description: Illustrates how long import sources can be formatted to improve readability. The `with` clause is given its own lines.
source: crates/biome_js_formatter/report.md#_snippet_10

language: javascript
code:
```
import a10 from "./aaaaaaaaaa.json" with { type: "json" };
import a20 from "./aaaaaaaaaaaaaaaaaaaa.json" with { type: "json" };
import a30 from "./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json" with { type: "json" };
import a40 from "./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json" with {
  type: "json",
};
import a50 from "./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json" with {
  type: "json",
};
import a60 from "./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json" with {
  type: "json",
};
import a70 from "./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json" with {
  type: "json",
};
import a80 from "./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json" with {
  type: "json",
};
```

language: javascript
code:
```
import("./aaaaaaaaaa.json", { with: { type: "json" } });
import("./aaaaaaaaaaaaaaaaaaaa.json", { with: { type: "json" } });
import("./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json", { with: { type: "json" } });
import("./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json", {
  with: { type: "json" },
});
import("./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json", {
  with: { type: "json" },
});
import("./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json", {
  with: { type: "json" },
});
import(
  "./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json",
  { with: { type: "json" } }
);
import(
  "./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json",
  { with: { type: "json" } }
);
```

---

title: Formatting Empty Imports with Comments - JavaScript
description: Illustrates how biome formats empty imports with various types of comments, including inline, multiline, and trailing comments. This ensures consistent and readable code when dealing with empty imports and comments.
source: crates/biome_js_formatter/report.md#_snippet_0

language: javascript
code:
```
 import {} from "@types/googlemaps";
 import "a";
 import /* comment */ "a";
 import // comment
 "a";
+import {/* comment */} from "a";
+import /* comment */ {} from "a";
+import {} /* comment */ from "a";
 import {} from /* comment */ "a";
-import {} from /* comment */ "a";
-import {} from /* comment */ "a";
-import {} from /* comment */ "a";
-import {} from /* comment */ /* comment */ /* comment */ /* comment */ "a";
+import /* comment */ {/* comment */} /* comment */ from /* comment */ "a";
+import {
+  // comment
+} from "a";
+import // comment
+{} from "a";
 import {} from // comment
 "a";
 import {} from // comment
 "a";
-import {} from // comment
-"a";
-import {} from // comment
-"a";
-import {} from // comment
-// comment
-// comment
+import // comment
+{
+  // comment
+} from // comment
+// comment
 "a";
 
 import // {} from
 "a";
 import {} from // comment ends with from
 "a";
 import {} from /* comment ends with from */ "a";
 import {} from // comment not ends with from ___
 "a";
 import {} from /* comment not ends with from ___ */ "a";
 
 import // comment ends with from
 "a";
 import /* comment ends with from */ "a";
 import // comment not ends with from ___
 "a";
 import /* comment not ends with from ___ */ "a";
```

---

title: Formatting Object Property Assignment Expressions - JavaScript
description: Illustrates how the formatter handles object property assignment expressions within an object literal. This example demonstrates the transformation of `this.resource = resource` to be enclosed within square brackets when used as a property key in an object literal, ensuring correct syntax and readability.
source: crates/biome_js_formatter/report.md#_snippet_1

language: javascript
code:
```
 a = {
-  [(this.resource = resource)]: 1,
+  [this.resource = resource]: 1,
 };
```

---

title: Looping Object Entries
description: Demonstrates how to iterate over the entries of an object and log them to the console. The `Object.entries(obj)` method converts an object into an array of `[key, value]` pairs, and `.forEach()` is used to loop through these pairs, logging each entry using `console.log(e)`.
source: crates/biome_js_formatter/report.md#_snippet_1

language: diff
code:
```
-Object.entries(obj)
+Object.entries(obj).forEach((e) => console.log(e));
 
-  .forEach((e) => console.log(e));
```

---

title: Fetching JSON Data
description: Demonstrates how to fetch JSON data from a server using `this.fetch('/foo')` and then parse the response as JSON using `.then((response) => response.json())`. This is a common pattern for making API requests and handling the response data.
source: crates/biome_js_formatter/report.md#_snippet_2

language: diff
code:
```
-this.fetch("/foo")
-
-  .then((response) => response.json());
+this.fetch("/foo").then((response) => response.json());
```

---

title: Using Unicode Keys in Objects
description: Illustrates how to use Unicode characters as keys in JavaScript objects. The example shows the difference between quoting and not quoting the Unicode key. When a Unicode key is not quoted, it's treated as a variable; quoting allows direct usage.
source: crates/biome_js_formatter/report.md#_snippet_3

language: diff
code:
```
 const obj = {
   a: true,
   b: true,
-  "[U+102A7]": true,
+  [U+102A7]: true,
 };
```

---

title: Formatting Template Literals with Expressions - JavaScript
description: Demonstrates the formatting of template literals containing various types of expressions, including nested properties, long strings, and conditional expressions. Highlights how Biome handles line wrapping and spacing within template literals to maintain readability.  Also shows how it manages template literals with expressions that access environment variables.
source: crates/biome_js_formatter/report.md#_snippet_0

language: javascript
code:
```
 const long1 = `long ${
   a.b //comment
 } long longlong ${a.b.c.d.e} long longlong ${a.b.c.d.e} long longlong ${a.b.c.d.e} long long`;
 const long2 = `long ${a.b.c.d.e} long longlong ${loooooooooooooooooong} long longlong ${loooooooooooooooooong} long longlong ${loooooooooooooooooong} long long`;
 
 const long3 = `long long long long long long long long long long long ${a.b.c.d.e} long long long long long long long long long long long long long`;
 
 const description = `The value of the ${cssName} css of the ${this._name} element`;
 
 const foo = `such a long template string ${foo.bar.baz} that prettier will want to wrap it`;
 
 const shouldWrapForNow = `such a long template string ${foo().bar.baz} that prettier will want to wrap it`;
 
 const shouldNotWrap = `simple expressions should not break ${this} ${variable} ${a.b.c} ${this.b.c} ${a[b].c} ${a.b[c]} ${a.b["c"]} ${a?.b?.c}`;
 
 console.log(
   chalk.white(
     `Covered Lines below threshold: ${coverageSettings.lines}%. Actual: ${coverageSummary.total.lines.pct}%`,
   ),
 );
 
 x = `mdl-textfield mdl-js-textfield ${className} ${
   content.length > 0 ? "is-dirty" : ""
 } combo-box__input`;
 
 function testing() {
   const p = {};
   // faking some tabs since I can't paste my real code in
   if (true) {
     if (false) {
       return `${process.env.OPENID_URL}/something/something/something?${Object.keys(
         p,
       )
         .map((k) => `${encodeURIComponent(k)}=${encodeURIComponent(p[k])}`)
         .join("&")}`;
     }
   }
 }
 
 console.log(
   `Trying update appcast for ${app.name} (${app.cask.appcast}) -> (${app.cask.appcastGenerated})`,
 );
 
 console.log(
   `brew cask audit --download ${_.map(definitions, "caskName").join(" ")}`,
 );
 
 console.log(
   `\nApparently jetbrains changed the release artifact for ${app.name}@${app.jetbrains.version}.\n`,
 );
 
 descirbe("something", () => {
   test(`{pass: false} expect(${small}).toBeGreaterThanOrEqual(${big})`, () => {});
 });
 
 throw new Error(
   `pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`,
 );
 
-a = `${[
-  [1, 2, 3],
-  [4, 5, 6],
-]}`;
+a = `${[[1, 2, 3], [4, 5, 6]]}`;
```

---

title: Formatting Await Expressions in Ternary Statements - JavaScript
description: Illustrates how Biome formats await expressions within ternary statements.  Shows how Biome ensures the code remains readable while adhering to consistent formatting rules, correctly placing parenthesis.
source: crates/biome_js_formatter/report.md#_snippet_1

language: javascript
code:
```
-stopDirectory = await (
-  useCache ? memoizedFindProjectRoot : findProjectRootWithoutCache
-)(path.dirname(path.resolve(filePath)));
+stopDirectory = await (useCache
+  ? memoizedFindProjectRoot
+  : findProjectRootWithoutCache)(path.dirname(path.resolve(filePath)));
```

---

title: Formatting Angular Inject Calls - JavaScript
description: Demonstrates the formatting of `inject` calls in AngularJS test declarations.  Shows how Biome handles multiline arguments and maintains readability in complex test setups. Correctly identifies the scope of function arguments passed to inject.
source: crates/biome_js_formatter/report.md#_snippet_2

language: javascript
code:
```
 beforeEach(inject(($fooService, $barService) => {
  // code
 }));
 
 afterAll(inject(($fooService, $barService) => {
  console.log("Hello");
 }));
 
 it("should create the app", inject(($fooService, $barService) => {
  //code
 }));
 
 it("does something really long and complicated so I have to write a very long name for the test", inject(() => {
  // code
 }));
 
-it("does something really long and complicated so I have to write a very long name for the test", inject((
-  $fooServiceLongName,
-  $barServiceLongName,
-) => {
+it("does something really long and complicated so I have to write a very long name for the test", inject(($fooServiceLongName, $barServiceLongName) => {
  // code
 }));
 
 /*
  * isTestCall(parent) should only be called when parent exists
  * and parent.type is CallExpression. This test makes sure that
  * no errors are thrown when calling isTestCall(parent)
  */
 function x() {
  inject(() => {});
 }
```

---

title: Formatting Optional Chaining in Test Declarations - JavaScript
description: Illustrates how Biome formats optional chaining (`?.`) in test declarations. The example showcases a `describe` block with optional chaining, and how Biome handles formatting this syntax.
source: crates/biome_js_formatter/report.md#_snippet_3

language: javascript
code:
```
-describe?.(
-  "some string some string some string some string some string some string some string some string",
-  (done) => {},
-);
+describe?.("some string some string some string some string some string some string some string some string", (done) => {});
```

---

title: Formatting Comments in JSX Attributes - JavaScript
description: Demonstrates how Biome formats comments within JSX attributes. It covers single-line and multiline comments, showcasing proper spacing and alignment within the attribute context. The example illustrates how Biome maintains readability even with embedded comments.
source: crates/biome_js_formatter/report.md#_snippet_4

language: javascript
code:
```
 <div attr=/* comment */ "foo"></div>;
 
 <div attr=/* comment */
 "foo"></div>;
 
-<div attr /* comment */="foo"></div>;
+<div attr=/* comment */
+"foo"></div>;
 
 <div attr=/* comment */ "foo"></div>;
 
 <div attr=// comment
 "foo"></div>;
 
-<div attr="foo"></div>; // comment
+<div attr=// comment
+"foo"></div>;
```

---

title: Formatting JSX Comments - Diff
description: Illustrates the impact of formatting changes on JSX comments within end tags. The diff highlights how line breaks and spacing within comments are adjusted to maintain code style consistency in `jsx/comments/in-end-tag.js`.
source: crates/biome_js_formatter/report.md#_snippet_0

language: diff
code:
```
/* =========== after name =========== */
-<a></a>; // line
+<a></a // line
+>;
 <a></a /* block */>;
```

---

title: Formatting FBT Components with Parameters - Diff
description: Demonstrates how the formatter modifies the spacing and line breaks within `<fbt>` components, specifically around `<fbt:param>` tags. These changes in `jsx/fbt/test.js` ensure consistent formatting and readability of FBT component structures.
source: crates/biome_js_formatter/report.md#_snippet_1

language: diff
code:
```
 x = (
   <fbt>
-    <fbt:param>First</fbt:param>,
-    <fbt:param>Second</fbt:param>
+    <fbt:param>First</fbt:param>,<fbt:param>Second</fbt:param>
   </fbt>
 );
 
 x = (
   <fbt>
-    <fbt:param>First</fbt:param>
-    ,
-    <fbt:param>Second</fbt:param>
+    <fbt:param>First</fbt:param>,<fbt:param>Second</fbt:param>
   </fbt>
 );
```

---

title: Formatting Asynchronous JSX with Await Expressions - Diff
description: Illustrates changes in formatting around `await` expressions within JSX. The diff in `jsx/jsx/await.js` highlights adjustments to line breaks and spacing to improve the readability and consistency of asynchronous JSX code.
source: crates/biome_js_formatter/report.md#_snippet_2

language: diff
code:
```
 async function testFunction() {
   const short = (
     <>
       {await Promise.all(hierarchyCriticism)}
       {await hierarchyCriticism.ic.me.oa.p}
       {await hierarchyCriticism}
 
       {Promise.all(hierarchyCriticism)}
       {hierarchyCriticism.ic.me.oa.p}
       {hierarchyCriticism}
     </>
   );
 
   const long = (
     <>
-      {await Promise.all(
-        hierarchyCriticismIncongruousCooperateMaterialEducationOriginalArticulateParameter,
-      )}
       {
+        await Promise.all(
+          hierarchyCriticismIncongruousCooperateMaterialEducationOriginalArticulateParameter,
+        )
+      }
+      {
         await hierarchyCriticism.IncongruousCooperate.MaterialEducation
           .OriginalArticulate.Parameter
       }
       {
         await hierarchyCriticismIncongruousCooperateMaterialEducationOriginalArticulateParameter
       }
```

---

title: Encoding HTML Entities in JSX Attributes - Diff
description: Demonstrates how the formatter handles HTML entity encoding in JSX attribute values. The diff in `jsx/jsx/quotes.js` shows how certain characters are encoded to ensure proper rendering in browsers, improving compatibility and security.
source: crates/biome_js_formatter/report.md#_snippet_3

language: diff
code:
```
 <div id="&quot;'<>&amp;quot;" />;
 <div id='"&#39;<>&amp;quot;' />;
 <div id={"\'\"&quot;<>&amp;quot;"} />;
 <div id="123" />;
-<div id='&#39;"' />;
+<div id="&#39;&quot;" />;
 <div id={"\'\"\\\'"} />;
 <div
   single="foo"
   single2={"foo"}
   double="bar"
   double2={"bar"}
   singleDouble='"'
   singleDouble2={'"'}
   doubleSingle="'"
   doubleSingle2={"\'"}
   singleEscaped={"\'"}
-  singleEscaped2="'"
+  singleEscaped2="&apos;"
   doubleEscaped={'"'}
-  doubleEscaped2='"'
+  doubleEscaped2="&quot;"
   singleBothEscaped={"\'\""}
-  singleBothEscaped2="'&quot;"
-  singleBoth="' &quot;"
+  singleBothEscaped2='&apos;"'
+  singleBoth='&apos; "'
   singleBoth2={"\' \""}
-  singleBoth3="' ' &quot;"
+  singleBoth3='&apos; &apos; "'
   doubleBoth="&quot; '"
   doubleBoth2={"\" '\""}
-  doubleBoth3="&quot; ' '""
+  doubleBoth3="&quot; &apos; '""
 />;
 
 <p>
   GitHub Desktop has encountered an unrecoverable error and will need to 1231231
   restart. This has been reported to the team, but if youencounter this121312331
   repeatedly please report this issue to the GitHub 12312312312312313{"  "}{" "}
 </p>;
```

---

title: Formatting Immutable.OrderedSet with Generic Types - TypeScript
description: Illustrates the proper formatting of `Immutable.OrderedSet` with generic types in TypeScript, ensuring that type parameters are correctly placed for readability.
source: crates/biome_js_formatter/report.md#_snippet_1

language: typescript
code:
```
-const durabilityMetricsSelectable: Immutable.OrderedSet<SomeReportingMetric> =
-  myExperienceSelectable.concat(otherDurabilityMetricsSelectable);
+const durabilityMetricsSelectable: Immutable.OrderedSet<
+  SomeReportingMetric,
+> = myExperienceSelectable.concat(otherDurabilityMetricsSelectable);
```

---

title: Handling Optional Chaining and Non-Null Assertions - TypeScript
description: Demonstrates how to correctly format and combine optional chaining (`?.`) and non-null assertion operators (`!`) in TypeScript. It includes various cases, such as member expressions and call expressions, to avoid potential formatting issues.
source: crates/biome_js_formatter/report.md#_snippet_2

language: typescript
code:
```
// Member expressions
a?.b!();
a?.b!();
(a!?.b)();
a.b?.c!();
a.b?.c!();
(a.b!?.c)();
(a!.b?.c)();
a?.b.c!();
a?.b.c!();
-(a?.b!.c)();
+a?.b!.c();
(a!?.b.c)();
a[b?.c]!();
a[b?.c]!();
a[b?.c!]();
a[b!?.c]();
(a?.b).c!();
(a?.b).c!();
// FIXME: ((a?.b!).c)   ();
(a!?.b).c();
a[b?.()]!();
a[b?.()]!();
a[b?.()!]();
a[b!?.()]();
a![b?.()]();
(a?.b).c!();
(a?.b).c!();
// FIXME: ((a?.b)!.c)   ();
// FIXME: ((a?.b!).c)   ();
(a!?.b).c();
(a?.()).b!();
(a?.()).b!();
-(a?.())!.b();
-(a?.())!.b();
+a?.()!.b();
+a?.()!.b();
(a!?.()).b();

// Call expressions
a?.()!();
a?.()!();
(a!?.())();
a.b.c?.()!();
a.b.c?.()!();
(a.b.c!?.())();
a.b?.c()!();
a.b?.c()!();
(a.b!?.c())();
a?.b.c()!();
a?.b.c()!();
-(a?.b!.c())();
+a?.b!.c()();
a(b?.c)!();
a(b?.c)!();
a(b?.c!)();
(a?.b)()!();
(a?.b)()!();
a?.b!()();
a?.b!()();
(a?.())()!();
(a?.())()!();
a?.()!()();
a?.()!()();
(a!?.())()();

// Not `.callee`
foo(a?.b!);
```

---

title: Formatting Optional Chaining and Non-Null Assertions in Member Expressions - TypeScript
description: Demonstrates how to correctly format optional chaining (`?.`) and non-null assertion operators (`!`) within member expressions in TypeScript. This example covers various combinations of these operators to ensure proper code formatting.
source: crates/biome_js_formatter/report.md#_snippet_3

language: typescript
code:
```
// Member expressions
-(a?.b)!.foo;
-(a?.b)!.foo;
+a?.b!.foo;
+a?.b!.foo;
(a!?.b).foo;
-(a.b?.c)!.foo;
-(a.b?.c)!.foo;
+a.b?.c!.foo;
+a.b?.c!.foo;
(a.b!?.c).foo;
(a!.b?.c).foo;
-(a?.b.c)!.foo;
-(a?.b.c)!.foo;
-(a?.b!.c).foo;
+a?.b.c!.foo;
+a?.b.c!.foo;
+a?.b!.c.foo;
(a!?.b.c).foo;
a[b?.c]!.foo;
a[b?.c]!.foo;
a[b?.c!].foo;
a[b!?.c].foo;
(a?.b).c!.foo;
(a?.b).c!.foo;
-(a?.b)!.c.foo;
+a?.b!.c.foo;
(a!?.b).c.foo;
a[b?.()]!.foo;
a[b?.()]!.foo;
a[b?.()!].foo;
a[b!?.()].foo;
a![b?.()].foo;
(a?.b).c!.foo;
(a?.b).c!.foo;
-(a?.b)!.c.foo;
-(a?.b)!.c.foo;
+a?.b!.c.foo;
+a?.b!.c.foo;
(a!?.b).c.foo;
(a?.()).b!.foo;
(a?.()).b!.foo;
-(a?.())!.b.foo;
-(a?.())!.b.foo;
+a?.()!.b.foo;
+a?.()!.b.foo;
(a!?.()).b.foo;

// Call expressions
-(a?.())!.foo;
-(a?.())!.foo;
+a?.()!.foo;
+a?.()!.foo;
(a!?.()).foo;
-(a.b.c?.())!.foo;
-(a.b.c?.())!.foo;
+a.b.c?.()!.foo;
+a.b.c?.()!.foo;
(a.b.c!?.()).foo;
-(a.b?.c())!.foo;
-(a.b?.c())!.foo;
+a.b?.c()!.foo;
+a.b?.c()!.foo;
(a.b!?.c()).foo;
-(a?.b.c())!.foo;
-(a?.b.c())!.foo;
-(a?.b!.c()).foo;
+a?.b.c()!.foo;
+a?.b.c()!.foo;
+a?.b!.c().foo;
a(b?.c)!.foo;
a(b?.c)!.foo;
a(b?.c!).foo;
(a?.b)()!.foo;
(a?.b)()!.foo;
a?.b!().foo;
a?.b!().foo;
(a?.())()!.foo;
(a?.())()!.foo;
a?.()!().foo;
a?.()!().foo;
(a!?.()).foo;

// Not `.object`
_[a?.b!](
```

---

title: Fixing Chain Expression Formatting - Typescript
description: Demonstrates how to fix the formatting of chain expressions in Typescript by removing unnecessary parentheses and ensuring correct placement of the non-null assertion operator.
source: crates/biome_js_formatter/report.md#_snippet_0

language: diff
code:
```
-(a?.b)!.c;
-(a?.())!.b;
-(a?.b)!.c;
-(a?.())!.b;
+a?.b!.c;
+a?.()!.b;
+a?.b!.c;
+a?.()!.b;
```

---

title: Accessing Rotation Property After Transform Handles - Typescript
description: Illustrates accessing the `rotation` property after calling the `getTransformHandles` function. It shows how to handle potential `null` or `undefined` values by using the non-null assertion operator `!` and optional chaining operator `?.`.
source: crates/biome_js_formatter/report.md#_snippet_1

language: diff
code:
```
{
  {
-    const rotation1 = getTransformHandles(
-      arrow,
-      h.state.zoom,
-      "mouse",
-    ).rotation!;
+    const rotation1 = getTransformHandles(arrow, h.state.zoom, "mouse")
+      .rotation!;
    const rotation2 = getTransformHandles(
      arrow,
      h.state.zoom,
      "mouse",
    ).rotation;
    const rotation3 = getTransformHandles(
      arrow,
      h.state.zoom,
      "mouse",
    )?.rotation;
  }
}
```

---

title: Defining Constructor Parameters with Access Modifiers - Typescript
description: Demonstrates different ways to define constructor parameters with access modifiers (`override`, `private`, `protected`, `public`, `readonly`) in Typescript. Also, shows how to define a static method that returns a new instance of the class.
source: crates/biome_js_formatter/report.md#_snippet_2

language: diff
code:
```
class C {
  constructor(override a: number) {}
}
class D {
  constructor(private a: number) {}
}
class E {
  constructor(protected a: number) {}
}
class F {
  constructor(public a: number) {}
}
class G {
  constructor(readonly a: number) {}
}
 
class A {
-  "constructor": typeof A;
+  'constructor': typeof A
  static Foo() {
    return new A();
  }
}
 
class B {
  constructor<>() {}
}
```

---

title: Formatting Empty Method Bodies with Comments - Typescript
description: Illustrates how to format empty method bodies with comments in Typescript classes. It highlights the correct placement of comments within the method signature, demonstrating the impact of code formatting on code readability.
source: crates/biome_js_formatter/report.md#_snippet_3

language: diff
code:
```
// #9324
 
class foo1 {
-  bar /* bat */();
+  bar() /* bat */;
}
 
// #9367
class Test {
-  foo /* 3 */(/* 2 */);
+  foo(/* 2 */) /* 3 */;
}
```

---

title: Declaring Class Properties - Typescript
description: Demonstrates how to declare class properties without quotes in Typescript. The example illustrates the change from using quoted property names to standard property names.
source: crates/biome_js_formatter/report.md#_snippet_4

language: diff
code:
```
class User {
-  "username": string;
+  username: string;
}
```

---

title: Decorating Class Elements With Comments - Typescript
description: Illustrates the proper placement of comments when using decorators on class elements in Typescript. It covers decorators on property definitions, abstract property definitions, abstract method definitions, method definitions, and accessor properties, along with constructor parameter properties.
source: crates/biome_js_formatter/report.md#_snippet_5

language: diff
code:
```
class Foo {
  // PropertyDefinition
-  @decorator /* comment */
-  readonly propertyDefinition;
+  @decorator
+  readonly /* comment */ propertyDefinition;
 
  // TSAbstractPropertyDefinition
-  @decorator /* comment */
-  abstract abstractPropertyDefinition;
+  @decorator
+  abstract /* comment */ abstractPropertyDefinition;
 
  // TSAbstractMethodDefinition
-  @decorator /* comment */
-  abstract abstractMethodDefinition;
+  @decorator
+  abstract /* comment */ abstractMethodDefinition;
 
  // MethodDefinition
-  @decorator /* comment */
-  private methodDefinition() {}
+  @decorator
+  private /* comment */ methodDefinition() {}
 
  // AccessorProperty
-  @decorator /* comment */
-  accessor accessorProperty = 3;
+  @decorator
+  accessor /* comment */ accessorProperty = 3;
 
  constructor(
    // TSParameterProperty
    @decorator
    readonly /* comment */ parameterProperty,
  ) {}
}
```

---

title: Decorating Constructor Parameters With Comments - Typescript
description: Illustrates the correct placement of comments when using decorators on constructor parameters in Typescript. The example demonstrates how comments should be positioned relative to the decorator and the `readonly` or `private` keywords.
source: crates/biome_js_formatter/report.md#_snippet_6

language: diff
code:
```
class Foo {
  constructor(
    @decorator1
-    readonly // comment1
-    baz1: string,
+    // comment1
+    readonly baz1: string,
 
    @decorator2
-    private // comment2
-    baz2: string,
+    // comment2
+    private baz2: string,
  ) {}
}
```

---

title: Declaring Functions With Comments - Typescript
description: Demonstrates how to declare functions with comments in Typescript. It focuses on maintaining code readability and ensuring that comments are correctly placed within the function signature.
source: crates/biome_js_formatter/report.md#_snippet_7

language: diff
code:
```
declare function fn(
  currentRequest: { a: number },
  // TODO this is a very very very very long comment that makes it go > 80 columns
): number;
 
-declare function /* foo */ f(/* baz */ a /* taz */); /* bar */
+declare function /* foo */ f(/* baz */ a /* taz */) /* bar */;
```

---

title: Formatting Mapped Types With Comments - Typescript
description: Illustrates the correct formatting of mapped types with various comment placements in Typescript. It shows how different comment positions around the mapping key affect the code's readability and structure.
source: crates/biome_js_formatter/report.md#_snippet_8

language: diff
code:
```
type A = {
  // commentA
  [a in A]: string;
};
 
type B = {
  /* commentB */ [b in B]: string;
};
 
type C = {
  [/* commentC */ c in C]: string;
};
 
type D = {
  [d /* commentD */ in D]: string;
};
 
type E = {
  [e in /* commentE */ E]: string;
};
 
type F = {
  [f in F /* commentF */]: string;
};
 
type G = {
-  [g in G /* commentG */]: string;
+  [g in G] /* commentG */ : string;
};
 
type H = { [/* commentH */ h in H]: string };
 
type I = { [/* commentI */ i in I]: string };
 
type J = { [j /* commentJ */ in J]: string };
 
type K = { [k in /* commentK */ K]: string };
 
type L = { [l in L /* commentL */]: string };
 
-type M = { [m in M /* commentG */]: string };
+type M = { [m in M] /* commentG */ : string };
```

---

title: Formatting Method Types With Comments - Typescript
description: Demonstrates how to format method types with comments in Typescript interfaces, type aliases, and abstract classes. It highlights various comment positions and their impact on code readability, covering function parameters, return types, and constructor signatures.
source: crates/biome_js_formatter/report.md#_snippet_9

language: diff
code:
```
interface foo1 {
  bar3 /* foo */(/* baz */); // bat
-  bar /* foo */ /* bar */?(/* baz */) /* bat */;
+  bar /* foo */?/* bar */ (/* baz */) /* bat */;
  bar2 /* foo */(/* baz */) /* bat */;
}
 
interface foo2 {
-  bar /* foo */?(/* bar */ bar: /* baz */ string): /* bat */ string;
+  bar /* foo */?/* bar */ (bar: /* baz */ string): /* bat */ string;
}
 
interface foo3 {
  /* foo */ (/* bar */): /* baz */ string;
}
 
interface foo4 {
  /* foo */ (bar: /* bar */ string): /* baz */ string;
}
 
interface foo5 {
-  /* foo */ new (/* bar */ a: /* baz */ string): /* bat */ string;
+  /* foo */ new /* bar */ (a: /* baz */ string): /* bat */ string;
}
 
interface foo6 {
-  /* foo */ new (/* baz */) /* bar */ : /* bat */ string;
+  /* foo */ new /* bar */ (/* baz */): /* bat */ string;
}
 
type foo7 = /* foo */ (/* bar */) /* baz */ => void;
 
type foo8 = /* foo */ (a: /* bar */ string) /* baz */ => void;
 
-let foo9: new (/* bar */) /* foo */ /* baz */ => string;
+let foo9: new /* foo */ (/* bar */) /* baz */ => string;
 
-let foo10: new (/* foo */ a: /* bar */ string) /* baz */ => string;
+let foo10: new /* foo */ (a: /* bar */ string) /* baz */ => string;
 
abstract class Test {
  abstract foo12 /* foo */(a: /* bar */ string): /* baz */ void;
 
  abstract foo13 /* foo */(/* bar */); /* baz */
}
```

---

title: Formatting Type Parameters With Comments - Typescript
description: Illustrates how to format type parameters with comments in Typescript functions and interfaces. It highlights the correct placement of comments within the type parameter list and their impact on code clarity.
source: crates/biome_js_formatter/report.md#_snippet_10

language: diff
code:
```
functionName<A /* A comment */>();
const a: T</* comment */> = 1;
functionName</* comment */>();
function foo</* comment */>() {}
interface Foo {
-  </* comment */>(arg): any;
+ </* comment */>(arg): any;
}
type T = </* comment */>(arg) => any;
 
functionName<A>(); // comment
const a: T<
  // comment
> = 1;
functionName<
  // comment
>();
function foo<
  // comment
>() {}
interface Foo {
  <
    A, // comment
  >(
    arg,
  ): any;
}
type T = <
  // comment
->(
-  arg,
-) => any;
+>(arg) => any;
```

---

title: Fixing Conditional Types Parentheses - Typescript Diff
description: Demonstrates changes needed to properly format conditional types involving parentheses in TypeScript. The diff highlights the addition of newlines and indentation for improved readability, particularly when dealing with complex type definitions involving `infer` and `TSESTree.Token`.
source: crates/biome_js_formatter/report.md#_snippet_0

language: typescript
code:
```
 // #13275
 type Foo<T> = T extends ((...a: any[]) => infer R extends string) ? R : never;
-type Foo<T> = T extends (new (...a: any[]) => infer R extends string)
+type Foo<T> = T extends (new (
+  ...a: any[]
+) => infer R extends string)
  ? R
  : never;
 
 // #14275
-type Test<T> = T extends ((
+type Test<T> = T extends (
  token: TSESTree.Token,
-) => token is infer U extends TSESTree.Token)
+) => token is infer U extends TSESTree.Token
  ? U
  : TSESTree.Token;
 type Test<T> = T extends ((
  token: TSESTree.Token,
 ) => asserts token is infer U extends TSESTree.Token)
  ? U
  : TSESTree.Token;
 type Test<T> = T extends (new (
-  token: TSESTree.Token,
-) => token is infer U extends TSESTree.Token)
+  token: TSESTree.Token
+) => token is infer U extends TSESTree.Token
+)
  ? U
-  : TSESTree.Token;
+  : TSESTree.Token
```

---

title: Illustrating Abstract Class Instantiations - Typescript Diff
description: Demonstrates the behavior of abstract classes and their instantiation in TypeScript. The diff corrects the syntax error where a method `baz` inside class `H` was incorrectly declared as `abstract baz(): number;` which is not allowed in non-abstract classes, which is fixed by changing it to `abstract baz() : number;`.
source: crates/biome_js_formatter/report.md#_snippet_1

language: typescript
code:
```
 class A {}
 
 abstract class B {
   foo(): number {
     return this.bar();
   }
   abstract bar(): number;
 }
 
 new B();
 
 var BB: typeof B = B;
 var AA: typeof A = BB;
 new AA();
 
 function constructB(Factory: typeof B) {
   new Factory();
 }
 
 var BB = B;
 new BB();
 
 var x: any = C;
 new x();
 
 class C extends B {}
 
 abstract class D extends B {}
 
 class E extends B {
   bar() {
     return 1;
   }
 }
 
 abstract class F extends B {
   abstract foo(): number;
   bar() {
     return 2;
   }
 }
 
 abstract class G {
   abstract qux(x: number): string;
   abstract qux(): number;
   y: number;
   abstract quz(x: number, y: string): boolean;
 
   abstract nom(): boolean;
   nom(x: number): boolean;
 }
 
 class H {
-  abstract baz(): number;
+  abstract baz() : number;
 }
```

---

title: Defining Abstract Class Modifiers - Typescript Diff
description: Illustrates the declaration of abstract members with modifiers (public, protected, private, static) in TypeScript abstract classes. The diff highlights that the `abstract` keyword should come before the modifier keywords.
source: crates/biome_js_formatter/report.md#_snippet_2

language: typescript
code:
```
 abstract class A {
   abstract foo_a();
 
   public abstract foo_b();
   protected abstract foo_c();
   private abstract foo_d();
 
-  public abstract foo_bb();
-  protected abstract foo_cc();
-  private abstract foo_dd();
+  abstract public foo_bb();
+  abstract protected foo_cc();
+  abstract private foo_dd();
 
-  static abstract foo_d();
+  abstract static foo_d();
 
   static abstract foo_e();
 }
```

---

title: Declaring Abstract Class Properties - Typescript Diff
description: Demonstrates the declaration of abstract properties with different access modifiers in a TypeScript abstract class. The diff shows that whitespace should be added to make the `private abstract w` properties and method return types consistent with the style in other lines.
source: crates/biome_js_formatter/report.md#_snippet_3

language: typescript
code:
```
 abstract class A {
   abstract x: number;
   public abstract y: number;
   protected abstract z: number;
-  private abstract w: number;
+  private abstract w : number;
 
   abstract m: () => void;
 
   abstract foo_x(): number;
   public abstract foo_y(): number;
   protected abstract foo_z(): number;
-  private abstract foo_w(): number;
+  private abstract foo_w() : number;
 }
```

---

title: Illustrating Readonly Constructor Assignment - TypeScript
description: Demonstrates the use of `readonly` in constructor parameters. It highlights the difference in syntax when `readonly` is combined with `public` or `private` access modifiers, and shows an example of accessing a `readonly` property outside the class, which results in a compilation error.
source: crates/biome_js_formatter/report.md#_snippet_0

language: diff
code:
```
 class C {
   constructor(readonly x: number) {}
 }
 new C(1).x = 2;
 
 class E {
-  constructor(public readonly x: number) {}
+  constructor(readonly public x: number) {}
 }
 
 class F {
   constructor(private readonly x: number) {}
 }
 new F(1).x;
```

---

title: Formatting React Hooks and Imperative Handles (JavaScript)
description: Demonstrates differences in formatting React `useEffect` and `useImperativeHandle` hooks within functional components.  The snippets highlight how the formatters handle long dependency arrays and multiline function bodies within these hooks.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_3

language: diff
code:
```
function helloWorld() {
  useEffect(() => {
    // do something
  }, [props.value]);
  useEffect(() => {
    // do something
  }, [
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
  ]);
}

function helloWorldWithReact() {
  React.useEffect(() => {
    // do something
  }, [props.value]);
  React.useEffect(() => {
    // do something
  }, [
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
    props.value,
  ]);
}

function MyComponent(props) {
  useEffect(
    () => {
      console.log("some code", props.foo);
    },

    // We need to disable the eslint warning here,
    // because of some complicated reason.
    // eslint-disable line react-hooks/exhaustive-deps
    [],
  );

  return null;
}

function Comp1() {
  const { firstName, lastName } = useMemo(
    () => parseFullName(fullName),
    [fullName],
  );
}

function Comp2() {
  const { firstName, lastName } = useMemo(
    () => func(),
    [
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
      props.value,
    ],
  );
}

function Comp3() {
  const { firstName, lastName } = useMemo(
    (aaa, bbb, ccc, ddd, eee, fff, ggg, hhh, iii, jjj, kkk) =>
      func(aaa, bbb, ccc, ddd, eee, fff, ggg, hhh, iii, jjj, kkk),
    [foo, bar, baz],
  );
}

function Comp4() {
  const { firstName, lastName } = useMemo(
    () =>
      (foo && bar && baz) ||
      baz ||
      (foo && baz(foo) + bar(foo) + foo && bar && baz) ||
      baz ||
      (foo && baz(foo) + bar(foo)),
    [foo, bar, baz],
  );
}

function Comp5() {
  const { firstName, lastName } = useMemo(() => func(), [foo]);
}

function Component1() {
-  useImperativeHandle(ref, () => {
-    /* Function body */
-  }, []);
-  useImperativeHandle(ref, () => {
-    /* Function body */
-  }, [props.value]);
-  useImperativeHandle(ref, () => {
-    /* Function body */
-  }, [
-    props.value,
-    props.value,
-    props.value,
-    props.value,
-    props.value,
-    props.value,
-    props.value,
-    props.value,
-    props.value,
-    props.value,
-    props.value,
-  ]);
+  useImperativeHandle(
+    ref,
+    () => {
+      /* Function body */
+    },
+    [],
+  );
+  useImperativeHandle(
+    ref,
+    () => {
+      /* Function body */
+    },
+    [props.value],
+  );
+  useImperativeHandle(
+    ref,
+    () => {
+      /* Function body */
+    },
+    [
+      props.value,
+      props.value,
+      props.value,
+      props.value,
+      props.value,
+      props.value,
+      props.value,
+      props.value,
+      props.value,
+      props.value,
+      props.value,
+    ],
+  );
}

function Component2() {
-  React.useImperativeHandle(ref, () => {
-    /* Function body */
-  }, []);
-  React.useImperativeHandle(ref, () => {
-    /* Function body */
-  }, [props.value]);
-  React.useImperativeHandle(ref, () => {
-    /* Function body */
-  }, [
-    props.value,
-    props.value,
-    props.value,
-    props.value,
-    props.value,
-    props.value,
-    props.value,
-    props.value,
-    props.value,
-    props.value,
-    props.value,
-  ]);
+  React.useImperativeHandle(
+    ref,
+    () => {
+      /* Function body */
+    },
+    [],
+  );
+  React.useImperativeHandle(
+    ref,
+    () => {
+      /* Function body */
+    },
+    [props.value],
+  );
+  React.useImperativeHandle(
+    ref,
+    () => {
+      /* Function body */
+    },
+    [
+      props.value,
+      props.value,
+      props.value,
+      props.value,
+      props.value,
+      props.value,
+      props.value,
+      props.value,
+      props.value,
+      props.value,
+      props.value,
+    ],
+  );
}

function Component3() {
-  useImperativeHandle(ref, () => {
-    /* Function body */
-  }, []);
+  useImperativeHandle(
+    ref,
+    () => {
+      /* Function body */
+    },
+    [],
+  );
}
```

---

title: Escaping Await Using Binding
description: Illustrates how to properly escape an await using binding. It ensures that the code remains valid when dealing with special characters.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_1

language: javascript
code:
```
 async function f() {
-  await using ab = c;
+  await using \u0061b = c;
 }
```

---

title: Using Await With Comments
description: Demonstrates the correct usage of `await using` with comments in different contexts such as blocks and loops.  It clarifies the placement of comments to avoid syntax errors and maintain code readability.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_2

language: javascript
code:
```
 async function f() {
   {
-    /*0*/ await using /*1*/ /*2*/ b /*3*/ = /*4*/ f(); /*5*/
+    /*0*/ await using /*1*/ /*2*/ b /*3*/ = /*4*/ f() /*5*/;
   }
   {
     /*0*/ for (
       /*1*/ /*2*/ await using /*3*/ /*4*/ b /*5*/ =
           /*6*/ x /*7*/ /*8*/ /*9*/ /*10*/;
       ;
-
     );
   }
   {
     /*0*/ for (/*1*/ /*2*/ await using /*3*/ /*4*/ b /*5*/ of /*6*/ x /*7*/ /*8*/);
   }
   {
     /*0*/ for await (/*1*/ /*2*/ /*3*/ await using /*4*/ /*5*/ b /*6*/ of /*7*/ x /*8*/ /*9*/);
   }
 }
```

---

title: Escaping Using Binding
description: Illustrates how to properly escape a using binding. It ensures that the code remains valid when dealing with special characters.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_3

language: javascript
code:
```
 {
-  using ab = c;
+  using \u0061b = c;
 }
```

---

title: Maintaining Blank Lines Between Export Specifiers
description: Illustrates how to properly maintain blank lines between export specifiers. This helps improve code readability by visually separating the exported variables.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_4

language: javascript
code:
```
 export {
   // a
   foo1,
-
   // b
   bar1,
   baz1,
 } from "mod";
 
 const foo2 = 1;
 const bar2 = 1;
 const baz2 = 1;
 
 export {
   // a
   foo2,
-
   // b
   bar2,
   baz2,
 };
```

---

title: Formatting For-In Loops With Initializers
description: Corrects formatting issues in `for...in` loops that contain initializers and complex expressions, particularly those involving parentheses and logical or binary operators. Ensures the generated code is syntactically valid and maintains the intended operator precedence.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_6

language: javascript
code:
```
 // https://github.com/babel/babel/blob/HEAD/packages/babel-generator/test/fixtures/parentheses/in-inside-for/input.js
 
 for (var a = (b in c) in {});
-for (var a = (1 || b in c) in {});
-for (var a = (1 + (2 || b in c)) in {});
-for (var a = (() => b in c) in {});
-for (var a = (1 || (() => b in c)) in {});
-for (var a = (() => {
+for (var a = 1 || (b in c) in {});
+for (var a = 1 + (2 || (b in c)) in {});
+for (var a = () => (b in c) in {});
+for (var a = 1 || (() => (b in c)) in {});
+for (var a = () => {
   b in c;
-}) in {});
-for (var a = ([b in c]) in {});
-for (var a = ({ b: b in c }) in {});
+} in {});
+for (var a = [(b in c)] in {});
+for (var a = { b: (b in c) } in {});
 // Meriyah can't parse
 // for (var a = (x = b in c) => {} in {});
-for (var a = (class extends (b in c) {}) in {});
-for (var a = (function (x = b in c) {}) in {});
+for (var a = class extends (b in c) {} in {});
+for (var a = function (x = (b in c)) {} in {});
```

---

title: Adding Semicolons to Conditional Expressions - JavaScript
description: Illustrates the addition of a semicolon in an `if` statement's body. This change ensures that the code block is correctly terminated, preventing potential parsing errors.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_1

language: diff
code:
```
   if (a)
-    if (b /* comment 6f */);
+    if (b); /* comment 6f */
    else return 2;
```

---

title: Adding Comments to Correct Do While Loops - JavaScript
description: Demonstrates how to add a comment at the end of a `do...while` loop when inside of an `if` statement. The added comment improves code readability and maintainability.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_2

language: diff
code:
```
  do {
    console.log(i);
-  } while (i--);
-// foo
+  } while (i--); // foo
 else bar();
```

---

title: Removing Assertions from Import Statements - JavaScript
description: Illustrates the removal of `assert {}` from import statements, updating the syntax to align with newer JavaScript standards where assertions might not be required or supported.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_8

language: diff
code:
```
-export * as bar from "bar.json" assert {};
+export * as bar from "bar.json";
```

---

title: Removing Assertions from Import Statements - JavaScript
description: Demonstrates the removal of `assert {}` clauses from import statements. The code now uses standard import syntax without assertions, which simplifies the import declarations.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_9

language: diff
code:
```
 export * as foo from "foo.json";
-export * as bar from "bar.json" assert {};
-export * as baz from "baz.json" /* comment */ assert {};
+export * as bar from "bar.json";
+export * as baz from "baz.json" /* comment */;
```

language: diff
code:
```
 import * as foo from "foo.json";
-import * as bar from "bar.json" assert {};
-import * as baz from "baz.json" /* comment */ assert {};
+import * as bar from "bar.json";
+import * as baz from "baz.json" /* comment */;
```

---

title: Removing Attributes from Import Statements - JavaScript
description: Illustrates the removal of `with {}` from export statements, simplifying the syntax. This change makes the code compatible with environments where import attributes are not supported.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_10

language: diff
code:
```
-export * as bar from "bar.json" with {};
+export * as bar from "bar.json";
```

---

title: Removing Attributes from Import Statements - JavaScript
description: Demonstrates removing `with {}` from JavaScript import and export statements. This update aligns the code with environments where import attributes are either unnecessary or not yet implemented.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_11

language: diff
code:
```
 export * as foo from "foo.json";
-export * as bar from "bar.json" with {};
-export * as baz from "baz.json" /* comment */ with {};
+export * as bar from "bar.json";
+export * as baz from "baz.json" /* comment */;
```

language: diff
code:
```
 import * as foo from "foo.json";
-import * as bar from "bar.json" with {};
-import * as baz from "baz.json" /* comment */ with {};
+import * as bar from "bar.json";
+import * as baz from "baz.json" /* comment */;
```

---

title: Adjusting Import Attribute Syntax - JavaScript
description: Illustrates changes to the syntax of import attributes in JavaScript. The updated code consolidates comments within the attribute declaration, improving readability and syntax correctness.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_12

language: diff
code:
```
-import "./test.json" /* assert */ /* assert */ with { type: "json" };
-import {} from "./test.json" /* assert */ /* assert */ with { type: "json" };
-import "./test.json" /* with */ /* with */ assert { type: "json" };
-import {} from "./test.json" /* with */ /* with */ assert { type: "json" };
+import "./test.json" /* assert */ with { /* assert */ type: "json" };
+import {} from "./test.json" /* assert */ with { /* assert */ type: "json" };
+import "./test.json" /* with */ assert { /* with */ type: "json" };
+import {} from "./test.json" /* with */ assert { /* with */ type: "json" };
```

language: diff
code:
```
-export {} from "./test.json" /* assert */ /* assert */ with { type: "json" };
-export {} from "./test.json" /* with */ /* with */ assert { type: "json" };
+export {} from "./test.json" /* assert */ with { /* assert */ type: "json" };
+export {} from "./test.json" /* with */ assert { /* with */ type: "json" };
```

---

title: Formatting Long Source Imports With Attributes - JavaScript
description: Demonstrates how to format long source imports with attributes for better readability. The updated code adds line breaks and indentation to the `with` clause, making the code easier to understand.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_13

language: diff
code:
```
 import a30 from "./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json" with { type: "json" };
-import a40 from "./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json" with { type: "json" };
-import a50 from "./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json" with { type: "json" };
-import a60 from "./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json" with { type: "json" };
-import a70 from "./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json" with { type: "json" };
-import a80 from "./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json" with { type: "json" };
+import a40 from "./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json" with {
+  type: "json",
+};
+import a50 from "./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json" with {
+  type: "json",
+};
+import a60 from "./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json" with {
+  type: "json",
+};
+import a70 from "./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json" with {
+  type: "json",
+};
+import a80 from "./aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json" with {
+  type: "json",
+};
```

---

title: Formatting Dangling Comments in Arrow Functions - JavaScript
description: Demonstrates how dangling comments within arrow functions are formatted. The snippet illustrates Biome's approach to handling comments in such contexts.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_1

language: javascript
code:
```
-foo(() =>
-  // foo
-  {},
+foo(
+  (
+    // foo
+  ) => {},
+);
```

---

title: Formatting Member Chains - JavaScript
description: Illustrates the formatting of long member chains in JavaScript. The snippet shows Biome's approach to preserving line breaks and comments within these chains, and also demonstrates the usage of `Object.entries`.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_3

language: javascript
code:
```
 fooBar
   .doSomething("Hello World")
   .doAnotherThing("Foo", { foo: bar })
 
   // App configuration.
   .doOneMoreThing(config)
 
   .run(() => console.log("Bar"));
 
 bigDeal
 
   .doSomething("Hello World")
 
   // Hello world
   .doAnotherThing("Foo", { foo: bar })
 
   // App configuration.
   .doOneMoreThing(config)
 
   .run(() => console.log("Bar"));
 
 foo.bar.baz
 
   .doSomething("Hello World")
 
   // Hello world
   .foo.bar.doAnotherThing("Foo", { foo: bar })
 
   .doOneMoreThing(config)
   .bar.run(() => console.log("Bar"));
 
 (
   somethingGood ? thisIsIt : maybeNot
 )
 
   // Hello world
   .doSomething("Hello World")
 
   .doAnotherThing("Foo", { foo: bar }) // Run this
   .run(() => console.log("Bar")); // Do this
 
 helloWorld
 
   .text()
 
   .then((t) => t);
 
 (
   veryLongVeryLongVeryLong ||
   anotherVeryLongVeryLongVeryLong ||
   veryVeryVeryLongError
 )
 
   .map((tickets) => TicketRecord.createFromSomeLongString())
 
   .filter((obj) => !!obj);
 
 const sel = this.connections
 
   .concat(this.activities.concat(this.operators))
   .filter((x) => x.selected);
 
-Object.entries(obj)
+Object.entries(obj).forEach((e) => console.log(e));
 
-  .forEach((e) => console.log(e));
-
-this.fetch("/foo")
-
-  .then((response) => response.json());
+this.fetch("/foo").then((response) => response.json());
```

---

title: Formatting Object Keys - JavaScript
description: Demonstrates how unicode characters are formatted as keys in JavaScript objects. This shows differences in how the formatter handles specific character escapes in object keys.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_4

language: javascript
code:
```
 const obj = {
   a: true,
   b: true,
-  "[U+102A7]": true,
+  [U+102A7]: true,
 };
```

---

title: Formatting Function Declarations - JavaScript
description: Demonstrates how a basic function declaration is formatted. The snippet illustrates the impact of formatting on whitespace and line breaks within the function definition.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_5

language: javascript
code:
```
 function a(
 ){
-  a();
-  b();
-  c();
-  d();
+a (
+);
+b();
+c(); d(
+);
+
 }
```

---

title: Whitespace Formatting in Function Calls - JavaScript
description: Illustrates how whitespace is handled in function calls. The snippet specifically shows the removal of unnecessary whitespace to adhere to a standardized coding style.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_6

language: javascript
code:
```
 a (
 );
-b (
-);                 c (
-); d(
+b();
+c(); d(
 );
```

---

title: Handling Range Boundaries - JavaScript
description: Demonstrates how range boundaries affect formatting. The snippet showcases the formatter's behavior when dealing with code that lies on the edge of a specified formatting range.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_7

language: javascript
code:
```
-foo = 1.0000;bar = 1.0;
-baz = 1.0;
+foo = 1.0000;bar = 1.0;baz=1.0000;
 // The range will be 13~26
 // `foo` ends at 13, should not format
 // `bar` ends at 26, should format
```

---

title: Formatting Class Declarations - JavaScript
description: Illustrates the formatting of a class declaration. This example demonstrates how the formatter handles whitespace and line breaks within a class definition.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_8

language: javascript
code:
```
+
+
 class a {
   b() {}
 }
 
-let x;
+let    x
```

---

title: Formatting Multiple Statements - JavaScript
description: Demonstrates how the formatter handles multiple statements. The snippet shows how function calls with arguments are formatted, specifically focusing on whitespace.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_9

language: javascript
code:
```
 call(
   1, 2,3
 );
 
 call(1, 2, 3);
 
 call(1, 2, 3);
 
-call(1, 2, 3);
+call(
+  1, 2,3
+);
```

---

title: Formatting Nested Statements - JavaScript
description: Demonstrates how nested statements are formatted, focusing on try-catch blocks and conditional statements. This snippet illustrates Biome's approach to structuring nested code.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_10

language: javascript
code:
```
 try {
-  1;
-  if (condition) {
-    body;
-  }
+1;
+if (condition) {
+  body;
+}
 }catch (err) {}
```

---

title: Removing Return Outside Function - JavaScript
description: Demonstrates the result of removing `return` outside of the scope of a function. The snippet illustrates Biome's refactoring style.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_11

language: javascript
code:
```
-return (
-  someVeryLongStringA &&
-  someVeryLongStringB &&
-  someVeryLongStringC &&
-  someVeryLongStringD
-);
+return someVeryLongStringA && someVeryLongStringB && someVeryLongStringC && someVeryLongStringD
```

---

title: Ignoring Sequence Expressions - JavaScript
description: Demonstrates the handling of sequence expressions with the `prettier-ignore` comment.  The snippet illustrates how the formatter respects the ignore directive when dealing with sequence expressions.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_12

language: javascript
code:
```
-+(
-  // prettier-ignore
-  ((
++// prettier-ignore
+((
       first
     )
     ,
     (
       last
-    ))
-);
+    )
+  );
```

---

title: Formatting Parenthesized Expressions - JavaScript
description: Demonstrates how parenthesized expressions are formatted. The snippet shows the formatter's approach to whitespace and line breaks within parenthesized constructs.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_13

language: javascript
code:
```
 console.log(
   /* 1 */
+
   /* 2 */
+
   /* 3 */
   (first,
   /* 4 */
   /* 5 */
   /* 6 */
+
   /* 7 */
   last),
   /* 8 */
   /* 9 */
   /* 10 */
 );
```

---

title: Sloppy Mode Function Declarations - JavaScript
description: Illustrates the formatting of function declarations within a while loop in sloppy mode.  The snippet demonstrates how the formatter modifies the code to adhere to a consistent style.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_14

language: javascript
code:
```
-while (false) function foo() {}
+while (false) function foo(){}
```

---

title: Adding Comments in JSX Attributes - JSX
description: Demonstrates how comments are placed within JSX attributes. The snippet illustrates different ways to add comments, including single-line and multiline comments, and shows how the formatter handles these comments.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_19

language: jsx
code:
```
 <div attr=/* comment */ "foo"></div>;
 
 <div attr=/* comment */
 "foo"></div>;
 
-<div attr /* comment */="foo"></div>;
+<div attr=/* comment */
+"foo"></div>;
 
 <div attr=/* comment */ "foo"></div>;
 
 <div attr=// comment
 "foo"></div>;
 
-<div attr="foo"></div>; // comment
+<div attr=// comment
+"foo"></div>;
```

---

title: Commenting in JSX End Tags - JavaScript
description: Demonstrates how comments are handled within JSX end tags. It shows the allowed placement of line and block comments before and after the slash and tag name, highlighting potential formatting differences.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_0

language: javascript
code:
```
/* =========== before slash =========== */
 <a></
   // line
   a
 >;
 <a></ /* block */
 a>;
 
 <></
   // line
 >;
 <></ /* block */>;
 
 /* =========== after slash =========== */
 <a></
   // line
   a
 >;
 <a></ /* block */
 a>;
 
 <></
   // line
 >;
 <></ /* block */>;
 
 /* =========== after name =========== */
-<a></a>; // line
+<a></a // line
+>;
 <a></a /* block */>;
 
 /* =========== block =========== */
 <a></a /* block */>;
 <></ /* block */>;
 
 /* =========== multiple ===========  */
 <a></
   // line 1
   // line 2
   a
 >;
 <a></ /* block1 */ /* block2 */
 a>;
 <a></
   /* block */ // line
   a
 >;
 
 <></
   // line 1
   // line 2
 >;
 <></ /* block1 */
   /* block2 */>;
 <></
   /* block */
   // line
 >;
```

---

title: Using Fbt Components in JSX - JavaScript
description: Illustrates the usage of `<fbt>` components for internationalization in JSX. The code demonstrates how to use `<fbt:param>` and `<fbt:enum>` within `<fbt>` to handle text variations and parameters, including complex scenarios with HTML elements and plurals.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_1

language: javascript
code:
```
x = (
  <fbt>
-    <fbt:param>First</fbt:param>,
-    <fbt:param>Second</fbt:param>
+    <fbt:param>First</fbt:param>,<fbt:param>Second</fbt:param>
  </fbt>
);

x = (
  <fbt>
-    <fbt:param>First</fbt:param>
-    ,
-    <fbt:param>Second</fbt:param>
+    <fbt:param>First</fbt:param>,<fbt:param>Second</fbt:param>
  </fbt>
);

x = (
  <fbt>
    <fbt:param>First</fbt:param>,<fbt:param>Second</fbt:param>
  </fbt>
);

x = (
  <fbt>
    <fbt:param>First</fbt:param>,<fbt:param>Second</fbt:param>
  </fbt>
);

x = (
  <fbt desc="example 1">
    Prefix comes before
    <fbt:param>
      <b>suffix</b>
    </fbt:param>
  </fbt>
);

x = (
  <fbt desc="example 2">
    Prefix comes before
    <fbt:param name="bold stuff">
      <b>suffix</b>
    </fbt:param>
    <fbt:param name="a link">
      <link href="#">suffix</link>
    </fbt:param>
  </fbt>
);

x = (
  <fbt desc="example 3">
    Count Chocula knows the the number
    <fbt:enum enum-range={["one", "two", "three"]} value={getValue()} />
    is awesome
  </fbt>
);

x = (
  <fbt>
    {hour}:{minute}:{second}
  </fbt>
);

x = (
  <fbt>
-    {hour}
-    :
-    {minute}
-    :
-    {second}
+    {hour}:{minute}:{second}
  </fbt>
);

x = (
  <fbt>
-    {hour}:
-    {minute}:
-    {second}
+    {hour}:{minute}:{second}
  </fbt>
);

first = (
  <fbt>
-    Text<br />
-    More text<br />
-    And more<br />
+    Text
+    <br />
+    More text
+    <br />
+    And more
+    <br />
  </fbt>
);

second = (
  <fbt>
-    Text<br />More text<br />And more<br />
+    Text
+    <br />
+    More text
+    <br />
+    And more
+    <br />
  </fbt>
);

third = (
  <fbt>
    Text
    <br />
    More text
    <br />
    And more
    <br />
  </fbt>
);
```

---

title: Awaiting Promises in JSX - JavaScript
description: Demonstrates how to use `await` within JSX to render asynchronous data. The example showcases awaiting `Promise.all` and direct property access on awaited values, illustrating the syntax for handling promises in JSX expressions.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_2

language: javascript
code:
```
async function testFunction() {
  const short = (
    <>
      {await Promise.all(hierarchyCriticism)}
      {await hierarchyCriticism.ic.me.oa.p}
      {await hierarchyCriticism}

      {Promise.all(hierarchyCriticism)}
      {hierarchyCriticism.ic.me.oa.p}
      {hierarchyCriticism}
    </>
  );

  const long = (
    <>
-      {await Promise.all(
-        hierarchyCriticismIncongruousCooperateMaterialEducationOriginalArticulateParameter,
-      )}
      {
        await Promise.all(
          hierarchyCriticismIncongruousCooperateMaterialEducationOriginalArticulateParameter,
        )
      }
      {
        await hierarchyCriticism.IncongruousCooperate.MaterialEducation
          .OriginalArticulate.Parameter
      }
      {
        await hierarchyCriticismIncongruousCooperateMaterialEducationOriginalArticulateParameter
      }

      {Promise.all(
        hierarchyCriticismIncongruousCooperateMaterialEducationOriginalArticulateParameter,
      )}
      {
        hierarchyCriticism.IncongruousCooperate.MaterialEducation
          .OriginalArticulate.Parameter
      }
      {
        hierarchyCriticismIncongruousCooperateMaterialEducationOriginalArticulateParameter
      }
    </>
  );

  const jsx = (
    <>
-      {await (
-        <IncongruousCooperate>
-          material education original articulate parameter
-        </IncongruousCooperate>
-      )}
      {
        await (
          <IncongruousCooperate>
            material education original articulate parameter
          </IncongruousCooperate>
        )
      }
    </>
  );
}
```

---

title: Encoding Attributes in JSX - JavaScript
description: Illustrates how JSX handles quotes and special characters in HTML attributes. The examples demonstrate different ways of encoding characters like `"`, `'`, `<`, `>`, and `&` within JSX attribute values, including the use of expressions and numeric character references.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_3

language: javascript
code:
```
<div id="&quot;'<>&amp;quot;" />;
<div id='"&#39;<>&amp;quot;' />;
<div id={"\'"&quot;<>&amp;quot;"} />;
<div id="123" />;
-<div id='&#39;"' />
+<div id="&#39;&quot;" />;
<div id={"\'"\\""} />;
<div
  single="foo"
  single2={"foo"}
  double="bar"
  double2={"bar"}
  singleDouble='"'
  singleDouble2={'"'}
  doubleSingle="'"
  doubleSingle2={"\'"}
  singleEscaped={"\'"}
-  singleEscaped2="'"
+  singleEscaped2="&apos;"
  doubleEscaped={'"'}
-  doubleEscaped2='"'
+  doubleEscaped2="&quot;"
  singleBothEscaped={"\'\""}
-  singleBothEscaped2="'&quot;"
-  singleBoth="' &quot;"
+  singleBothEscaped2='&apos;"'
+  singleBoth='&apos; "'
  singleBoth2={"\' \""}
-  singleBoth3="' ' &quot;"
+  singleBoth3='&apos; &apos; "'
  doubleBoth="&quot; '\""
  doubleBoth2={"\" '\""}
-  doubleBoth3="&quot; ' '""
+  doubleBoth3="&quot; &apos; '""
/>;

<p>
  GitHub Desktop has encountered an unrecoverable error and will need to 1231231
  restart. This has been reported to the team, but if youencounter this121312331
  repeatedly please report this issue to the GitHub 12312312312312313{"  "}{" "}
</p>;
```

---

title: Commenting in Arrow Functions - TypeScript
description: Demonstrates how to properly place comments within arrow functions. The code shows that a comment should be placed after the closing curly brace of the function body.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_5

language: typescript
code:
```
const fn1 = () => {
  return;
-}; /* foo */
+} /* foo */;

const fn2 = () => {
  return;
};

// foo
```

---

title: Using Non-Null Assertion with Optional Chaining in Member Expressions - TypeScript
description: Demonstrates the use of the non-null assertion operator (`!`) in combination with optional chaining (`?.`) in member expressions in TypeScript. It shows how to assert that the result of an optional chain is not null before accessing a property.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_8

language: typescript
code:
```
  // Computed
  a?.b!,
)[foo];
```

---

title: Formatting Chain Expression - Typescript
description: Demonstrates the change in formatting of chain expressions using optional chaining and non-null assertion operators in TypeScript. This update alters the placement of the non-null assertion operator, improving code readability.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_0

language: typescript
code:
```
a?.b!.c;
a?.()!.b;
a?.b!.c;
a?.()!.b;
```

---

title: Accessing Rotation Property with Optional Chaining - Typescript
description: Illustrates accessing the `rotation` property of an object returned by `getTransformHandles` using optional chaining. This ensures that the code doesn't throw an error if `getTransformHandles` returns `null` or `undefined`, making the code more robust.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_1

language: typescript
code:
```
const rotation1 = getTransformHandles(arrow, h.state.zoom, "mouse")
      .rotation!;
    const rotation2 = getTransformHandles(
      arrow,
      h.state.zoom,
      "mouse",
    ).rotation;
    const rotation3 = getTransformHandles(
      arrow,
      h.state.zoom,
      "mouse",
    )?.rotation;
```

---

title: Defining Constructor with Modifiers - Typescript
description: Demonstrates defining a class constructor in TypeScript with `override`, `private`, `protected`, `public` and `readonly` modifiers. These modifiers control the accessibility and mutability of the constructor parameters, influencing how instances of the class can be used and modified.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_2

language: typescript
code:
```
class C {
  constructor(override a: number) {}
}
class D {
  constructor(private a: number) {}
}
class E {
  constructor(protected a: number) {}
}
class F {
  constructor(public a: number) {}
}
class G {
  constructor(readonly a: number) {}
}
```

---

title: Formatting Empty Method Body - Typescript
description: Illustrates a change in formatting of empty method bodies in TypeScript classes. This affects how comments are positioned relative to the parentheses of a method definition, impacting code style and readability.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_3

language: typescript
code:
```
class foo1 {
  bar() /* bat */;
}

// #9367
class Test {
  foo(/* 2 */) /* 3 */;
}
```

---

title: Defining Quoted Property - Typescript
description: Illustrates how to define a property within a class. This impacts how properties are defined and accessed within class instances.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_4

language: typescript
code:
```
class User {
  username: string;
}
```

---

title: Placing Comments with Decorators - Typescript
description: Demonstrates how comments are placed in relation to decorators in TypeScript. These changes affect the formatting of code where decorators are used, especially around class properties, methods, and constructors, enhancing code readability and maintainability.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_5

language: typescript
code:
```
class Foo {
  // PropertyDefinition
  @decorator
  readonly /* comment */ propertyDefinition;

  // TSAbstractPropertyDefinition
  @decorator
  abstract /* comment */ abstractPropertyDefinition;

  // TSAbstractMethodDefinition
  @decorator
  abstract /* comment */ abstractMethodDefinition;

  // MethodDefinition
  @decorator
  private /* comment */ methodDefinition() {}

  // AccessorProperty
  @decorator
  accessor /* comment */ accessorProperty = 3;

  constructor(
    // TSParameterProperty
    @decorator
    readonly /* comment */ parameterProperty,
  ) {}
}
```

---

title: Positioning Comments in Constructor Parameters - Typescript
description: Illustrates changes in how comments are positioned within constructor parameters decorated with decorators in TypeScript. This formatting adjustment impacts code readability, especially in constructors with multiple decorated parameters.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_6

language: typescript
code:
```
class Foo {
  constructor(
    @decorator1
    // comment1
    readonly baz1: string,

    @decorator2
    // comment2
    private baz2: string,
  ) {}
}
```

---

title: Formatting Declare Function Comments - Typescript
description: Demonstrates changes in the formatting of comments within `declare function` statements in TypeScript.  The formatting changes affect the placement of comments within the function signature.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_7

language: typescript
code:
```
declare function /* foo */ f(/* baz */ a /* taz */) /* bar */;
```

---

title: Positioning Comments in Mapped Types - Typescript
description: Illustrates how comments are positioned within mapped types in TypeScript. The formatting changes affect the placement of comments within the type definitions, potentially improving or hindering readability based on the complexity of the type.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_8

language: typescript
code:
```
type G = {
  [g in G] /* commentG */ : string;
};

type M = { [m in M] /* commentG */ : string };
```

---

title: Formatting Comments in Method Types - Typescript
description: Demonstrates changes in how comments are formatted within method types in TypeScript interfaces and type definitions. This impacts code readability where comments are used extensively to document method signatures.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_9

language: typescript
code:
```
interface foo1 {
  bar3 /* foo */(/* baz */); // bat
  bar /* foo */?/* bar */ (/* baz */) /* bat */;
  bar2 /* foo */(/* baz */) /* bat */;
}

interface foo2 {
  bar /* foo */?/* bar */ (bar: /* baz */ string): /* bat */ string;
}

interface foo5 {
  /* foo */ new /* bar */ (a: /* baz */ string): /* bat */ string;
}

interface foo6 {
  /* foo */ new /* bar */ (/* baz */): /* bat */ string;
}

let foo9: new /* foo */ (/* bar */) /* baz */ => string;

let foo10: new /* foo */ (a: /* bar */ string) /* baz */ => string;
```

---

title: Formatting Comments in Type Parameters - Typescript
description: Demonstrates changes in how comments are positioned within type parameters in TypeScript functions, interfaces, and type aliases. This influences code readability, especially when comments are used to describe type parameters.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_10

language: typescript
code:
```
interface Foo {
 </* comment */>(arg): any;
}
type T = </* comment */>(arg) => any;

interface Foo {
  <
    A, // comment
  >(
    arg,
  ): any;
}
type T = <
  // comment
>(arg) => any;
```

---

title: Instantiating Abstract Class - Typescript
description: Illustrates an attempt to instantiate abstract classes directly, which is not allowed in TypeScript. The code also shows that assignment between a concrete class constructor and an abstract class constructor is not allowed.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_12

language: typescript
code:
```
class H {
  abstract baz() : number;
}
```

---

title: Ordering Abstract Class Modifiers - Typescript
description: Demonstrates the changes in the order of modifiers (like `public`, `protected`, `private`, and `static`) when used with the `abstract` keyword in TypeScript class declarations. This affects how abstract members are defined and how their accessibility is controlled.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_13

language: typescript
code:
```
abstract class A {
  abstract foo_a();

  abstract public foo_bb();
  abstract protected foo_cc();
  abstract private foo_dd();

  abstract static foo_d();

  static abstract foo_e();
}
```

---

title: Defining Abstract Properties - Typescript
description: Demonstrates the syntax for declaring abstract properties, including public, protected, and private abstract properties. This affects how derived classes must implement these properties.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_14

language: typescript
code:
```
abstract class A {
  abstract x: number;
  public abstract y: number;
  protected abstract z: number;
  private abstract w : number;

  abstract m: () => void;

  abstract foo_x(): number;
  public abstract foo_y(): number;
  protected abstract foo_z(): number;
  private abstract foo_w() : number;
}
```

---

title: Declaring Readonly Constructor Parameters - Typescript
description: Illustrates the use of the `readonly` keyword in constructor parameters in TypeScript. This allows the creation of class properties that are initialized in the constructor and cannot be modified afterwards, promoting immutability.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_15

language: typescript
code:
```
class E {
  constructor(readonly public x: number) {}
}
```

---

title: Using Abstract Private Properties - Typescript
description: Demonstrates the declaration of abstract private properties within a class. This ensures derived classes implement these properties.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_16

language: typescript
code:
```
abstract class Foo {
  abstract private a: 1;
  private abstract b: 2;
  static abstract c: 3;
  abstract private ['g'];
  private abstract ['h'];
  static abstract ['i'];
}
```

---

title: Defining Object Type in Declare Function - TypeScript
description: Illustrates how Biome formats object types within `declare function` declarations, specifically handling line breaks and spacing within the object type definition.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_0

language: typescript
code:
```
declare function foo(this: { a: boolean; b: string; c: number }): Promise<
  Array<foo>
>;

declare function bazFlip({
  a: boolean,
  b: string,
  c: number,
}): Promise<Array<foo>>;

declare function bar(
  ...{ a: boolean, b: string, c: number }
): Promise<Array<foo>>;

declare function bar(
  ...x: { a: boolean; b: string; c: number }
): Promise<Array<foo>>;
```

---

title: Using Trailing Commas in Function Rest Parameters - TypeScript
description: Demonstrates how Biome handles trailing commas in function rest parameters within `declare function` declarations, adding a comma after the rest parameter.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_1

language: typescript
code:
```
declare function foo(...args: any[], )
declare function foo(...long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_args: any[], )
```

---

title: Formatting Angular Component Decorators - TypeScript
description: Shows how Biome formats the `template` property within the `@Component` decorator in Angular, specifically handling spacing within the template string.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_2

language: typescript
code:
```
@Component({
  selector: "toh-hero-button",
  template: `<button>{{label}}</button>`,
})
export class HeroButtonComponent {
  @Output() change = new EventEmitter<any>();
  @Input() label: string;
}
```

---

title: Formatting TypeORM Entity Relationships - TypeScript
description: Illustrates how Biome formats the `@OneToMany` decorator in TypeORM entities, focusing on line breaks and spacing within the decorator's arguments.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_3

language: typescript
code:
```
@Entity()
export class Board {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  slug: string;

  @Column()
  name: string;

  @Column()
  theme: string;

  @Column()
  description: string;

  @OneToMany(
    (type) => Topic,
    (topic) => topic.board,
  )
  topics: Topic[];
}
```

---

title: Handling Comments with Decorators - TypeScript
description: Demonstrates how Biome preserves comments when using decorators on class methods and properties, ensuring that comments are not misplaced during formatting.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_4

language: typescript
code:
```
class Foo1 {
  @foo
  // comment
  async method() {}
}

class Foo2 {
  @foo
  // comment
  private method() {}
}

class Foo3 {
  @foo
  // comment
  *method() {}
}

class Foo4 {
  @foo
  // comment
  async *method() {}
}

class Something {
  @foo()
  // comment
  readonly property: Array<string>;
}

class Something2 {
  @foo()
    // comment
    abstract property: Array<string>
}
```

---

title: Formatting Definite Assignment Assertions - TypeScript
description: Shows how Biome formats definite assignment assertions (`!`) on class properties and variables, focusing on spacing and placement of the assertion operator.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_5

language: typescript
code:
```
class Foo {
  a!
  #b!
  static c!
  [d]! = 1
  'e'!
}

let a! = x
const b! = x
var c/* */! = x
export const d! = x
```

---

title: Handling Empty Imports with Comments - TypeScript
description: Illustrates how Biome formats empty import statements (`import type {}`) with various comments, ensuring that comments are preserved and correctly positioned.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_6

language: typescript
code:
```
import type {} from "@types/googlemaps";
import "a";
import /* comment */ "a";
import // comment
 "a";
import type {/* comment */} from "a";
import /* comment */ type {} from "a";
import type {} /* comment */ from "a";
import type {} from /* comment */ "a";
import /* comment */ type {/* comment */} /* comment */ from /* comment */ "a";
import type {
  // comment
} from "a";
import // comment
 type {} from "a";
import type {} from // comment
"a";
import type // comment
{
  // comment
} from // comment
// comment
"a";

import // {} from
"a";
import type {} from // comment ends with from
"a";
import type {} from /* comment ends with from */ "a";
import type {} from // comment not ends with from ___
"a";
import type {} from /* comment not ends with from ___ */ "a";

import // comment ends with from
"a";
import /* comment ends with from */ "a";
import // comment not ends with from ___
"a";
import /* comment not ends with from ___ */ "a";
```

---

title: Formatting Type Modifiers in Imports and Exports - TypeScript
description: Demonstrates how Biome formats type modifiers in import and export statements, specifically focusing on spacing and syntax for type-only imports and exports.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_7

language: typescript
code:
```
export type { SomeThing };
export type { A as B };
export type { B as C } from "./a";
export type { foo } from "bar";
export type { foo };

// this should be treated as a normal import statement
import type from "./foo";

import type { SomeThing } from "./some-module.js";
import type { foo, bar } from "baz";
import type { foo as bar } from "baz";
import type * as foo from "./bar";
import type foo from "bar";
import type foo, { bar } from 'bar';
```

---

title: Breaking Long Interface Inheritance Chains - TypeScript
description: Illustrates how Biome breaks long inheritance chains in interface declarations to improve readability, specifically when extending multiple interfaces or generic types.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_8

language: typescript
code:
```
export interface Environment1 extends GenericEnvironment<
  SomeType,
  AnotherType,
  YetAnotherType,
> {
  m(): void;
}
export class Environment2 extends GenericEnvironment<
  SomeType,
  AnotherType,
  YetAnotherType,
  DifferentType1,
  DifferentType2,
  DifferentType3,
  DifferentType4,
> {
  m() {};
}

// Declare Interface Break
declare interface ExtendsOne extends ASingleInterface {
  x: string;
}

declare interface ExtendsLarge
  extends ASingleInterfaceWithAReallyReallyReallyReallyLongName {
  x: string;
}

declare interface ExtendsMany
  extends Interface1,
    Interface2,
    Interface3,
    Interface4,
    Interface5,
    Interface6,
    Interface7 {
  x: string;
}

// Interface declaration break
interface ExtendsOne extends ASingleInterface {
  x: string;
}

interface ExtendsLarge
  extends ASingleInterfaceWithAReallyReallyReallyReallyLongName {
  x: string;
}

interface ExtendsMany
  extends Interface1,
    Interface2,
    Interface3,
    Interface4,
    Interface5,
    Interface6,
    Interface7 {
  s: string;
}

// Generic Types
interface ExtendsOne extends ASingleInterface<string> {
  x: string;
}

interface ExtendsLarge
  extends ASingleInterfaceWithAReallyReallyReallyReallyLongName<string> {
  x: string;
}

interface ExtendsMany
  extends ASingleGenericInterface<
    Interface1,
    Interface2,
    Interface3,
    Interface4,
    Interface5,
    Interface6,
    Interface7
  > {
  x: string;
}

interface ExtendsManyWithGenerics
  extends InterfaceOne,
    InterfaceTwo,
    ASingleGenericInterface<
      Interface1,
      Interface2,
      Interface3,
      Interface4,
      Interface5,
      Interface6,
      Interface7
    >,
    InterfaceThree {
  x: string;
}

export interface ExtendsLongOneWithGenerics
  extends Bar<
    SomeLongTypeSomeLongTypeSomeLongTypeSomeLongType,
    ToBreakLineToBreakLineToBreakLine
  > {}
```

---

title: Formatting Intersection Types with Parentheses - TypeScript
description: Demonstrates how Biome formats intersection types involving union types and parentheses, specifically focusing on preserving comments and spacing.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_9

language: typescript
code:
```
type A = (number | string) & boolean;
type B = (number | string) & boolean;
type C = (number | string) & boolean;
type D = (number | string) & boolean;

let b1: C;
let b2: C;
let b3: C;
let b4: C;
let b5: C;
let b6: /*1*/ C;
let b7: /*1*/ C;
let b8: /*1*/ C;
let b9: /*1*/ C;
let b10: /*1*/ /*2*/ C;
let b11: /*1*/ /*2*/ C;

let bb1: /*1*/ /*2*/ C & D;
let bb2: /*1*/ /*2*/ C & /*3*/ D;
let bb3: /*1*/ /*2*/ C & /*3*/ D /*5*/;

type B2 = C;
type B3 = C;
type B4 = C;
type B5 = C;
type B6 = /*1*/ C;
type B7 = /*1*/ C;
type B8 = /*1*/ C;
type B9 = /*1*/ C;
type B10 = /*1*/ /*2*/ C;
type B11 = /*1*/ /*2*/ C;
type B12 = /*1*/ C;

type Bb1 = /*1*/ /*2*/ C & D;
type Bb2 = /*1*/ /*2*/ C & /*3*/ D;
type Bb3 = /*1*/ /*2*/ C & /*3*/ D /*4*/;

type D1 = /*1*/ a & b;
type D2 = /*1*/ a & b;
type D3 = /*1*/ a & b;
type D4 = /*1*/ a & b;
type D5 = /*1*/ a & b;
type D6 /*0*/ = /*1*/ a & b;
```

---

title: Formatting Decorated Function
description: Demonstrates the formatting changes applied to a decorated function in a TypeScript file. The diff shows changes in spacing and line breaks within the function definition.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_0

language: typescript
code:
```
const Counter = decorator("my-counter")(  (props: { initialCount?: number; label?: string }) => {    const p = useDefault(props, {      initialCount: 0,      label: "Counter",    });
    const [s, set] = useState({ count: p.initialCount });    const onClick = () => set("count", (it) => it + 1);
    return () => (      <button onclick={onClick}>        {p.label}: {s.count}      </button>    );  },);
```

---

title: Formatting CSS Interpolation
description: Illustrates the application of CSS within a styled component using interpolation. The change involves adjusting the indentation and line breaks within the `css` function.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_1

language: typescript
code:
```
const yesFrame = (  ...args: Interpolation<ThemedStyledProps<{}, Theme>>[]) => css`    ${ChatRoot}[data-frame="yes"] & {        ${css({}, ...args)}    } `;
```

---

title: Adjusting Optional Chain Formatting
description: Illustrates changes in the formatting of optional chaining and non-null assertions in TypeScript. The diff focuses on removing unnecessary parentheses and ensuring consistent spacing around the `!.` operator.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_2

language: typescript
code:
```
a?.b!.c;a?.b!.c.d;a?.b.c!.d;a!.b?.c;a?.b!?.c;a?.b!.c?.c;a?.b!.c;a?.b!.c;

a?.().b!.c;a?.().b!.c.d;a?.().b.c!.d;a?.().b!?.c;a?.().b!.c?.c;a?.().b!.c;a?.().b!.c;

a?.b![c?.d!];
```

---

title: Adjusting Satisfies Operator Formatting
description: Demonstrates changes related to the `satisfies` operator, including line breaks and comment placement. The example shows how a comment affects the formatting of a `satisfies` expression in TypeScript.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_7

language: typescript
code:
```
const t1 = {  prop1: 1,  prop2: 2,  prop3: 3,} satisfies  // Comment  Record<string, number>;
```

---

title: Adjusting Test Declaration Formatting
description: Shows the formatting adjustments in a TypeScript test declaration. The change ensures that the type parameter declaration is formatted correctly, adding line breaks for better readability.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_8

language: typescript
code:
```
test("does something really long and complicated so I have to write a very long name for the test", <  T,>(done) => {  console.log("hello!");});
```

---

title: Adding Trailing Comma to Object Destructuring
description: Demonstrates the addition of a trailing comma in an object destructuring assignment. Adding trailing commas can reduce diff sizes and avoid merge conflicts when new elements are added.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_9

language: typescript
code:
```
const {  longKeySoThisWillGoOnMultipleLines,  longKeySoThisWillGoOnMultipleLines2,  longKeySoThisWillGoOnMultipleLines3,  ...rest,} = something;
```

---

title: Formatting Type Parameters vs Arguments
description: Illustrates formatting changes related to type parameters in a class instantiation. The change enforces a consistent formatting style, specifically related to commas after type parameters.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_10

language: typescript
code:
```
const instance = new FooClass<  boolean,  number,  string, // [ts] Trailing comma not allowed.  >();
```

---

title: Adjusting Conditional Type Formatting
description: Demonstrates formatting changes applied to conditional types in TypeScript. The changes involve adding line breaks and indentation to improve the readability and structure of complex type definitions.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_11

language: typescript
code:
```
type FallbackFlags<F extends Flags | undefined> = Equals<  NonNullableFlag<F>["flags"],  {}>> extends true  ? Dict<any>  : NonNullableFlag<F>["flags"];

export type UnPromise<Type extends Promise<unknown>> = Type extends Promise<  infer Generic>  ? Generic  : never;

export type Equals<X, Y> = (<T>() => T extends X ? 1 : 2) extends <  T,>() => T extends Y ? 1 : 2  ? true  : false;

export type _Repeat<  A extends any,  N extends number,  L extends List = [],> = __Repeat<N, A, L> extends infer X ? Cast<X, List> : never;

export type Repeat<  A extends any,  N extends number,  L extends List = [],> = N extends unknown ? (L extends unknown ? _Repeat<A, N, L> : never) : never;

export type Intersect<U1 extends any, U2 extends any> = U1 extends unknown  ? U2 extends unknown    ? { 1: U1; 0: never }[Equals<U1, U2>]    : never  : never;
```

---

title: Adjusting Const Type Parameter Formatting
description: Illustrates changes in the formatting of `const` type parameters in TypeScript functions, classes, and interfaces. The diff highlights how the formatter enforces consistent spacing and arrangement of `const` type parameters.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_12

language: typescript
code:
```
function a<const T>() {}
function b<const T extends U>() {}
function c<T, const U>() {}
declare function d<const T>();
<const T,>() => {};
<const T extends U>() => {};
(function <const T>() {});
(function <const T extends U>() {});
(function <T, const U>() {});

class A<const T> {}
class B<const T extends U> {}
class C<T, const U>() {}
class D<const in T> {}
class E<const in T>() {}
(class<const T> {});
(class<const T extends U> {});
(class<T, const U>() {});
(class<const in T> {});
(class<const in T> {});

interface I<const T> {}
interface J<const T extends U> {}
interface K<T, const U> {}
interface L<in const T> {}
interface M<const in T> {}

class _ {
  method<const T>() {}
  method<const T extends U>() {}
  method<T, const U>() {}
}
```

---

title: Simplifying Empty Parameters With Arrow Function
description: Demonstrates simplifying the formatting of arrow functions with empty parameters. The change shows removing unnecessary parentheses around single parameters.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_13

language: typescript
code:
```
const xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx: xxxxxxxxxxxxxxxxxxxxxx<> =  arg => null;

const xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx: xxxxxxxxxxxxxxxxxxxxxx</* comment */> =  arg => null;

const xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx: xxxxxxxxxxxxxxxxxxxxxx<  // comment> =  arg => null;
```

---

title: Fixing Type Parameter Line Breaking After Extends - TypeScript
description: Demonstrates how to fix the line breaking after the `extends` keyword in TypeScript type parameters. This ensures consistent formatting of complex type definitions, improving readability.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_0

language: diff
code:
```
 a = {
   parseFunctionBodyAndFinish<
     T extends
       | N.Function
       | N.TSDeclareMethod
       | N.TSDeclareFunction
       | N.ClassPrivateMethod,
   >() {},
 };
 
 function parseFunctionBodyAndFinish<
   T extends
     | N.Function
     | N.TSDeclareMethod
     | N.TSDeclareFunction
     | N.ClassPrivateMethod
     | Foo
     | Bar
     | Baz,
 >();
 
 function parseFunctionBodyAndFinish<
   T extends // comment
-    N.Function | N.TSDeclareMethod | Baz,
+  N.Function | N.TSDeclareMethod | Baz,
 >();
 
 function makeChainWalker<
   ArgT extends {
     options: ValidatedOptions;
     dirname: string;
     filepath?: string;
   },
 >() {}
```

---

title: Enforcing Consistent Formatting With Prettier Ignore - TypeScript
description: Illustrates how `prettier-ignore` comments can be used to enforce consistent formatting of complex type definitions in TypeScript.  Specifically, this diff shows that prettier ignore can be used to not include the parenthesis in a union type.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_1

language: diff
code:
```
 export type a =
   // foo
   | (foo1 & foo2)
   // bar
   | (bar1 & bar2)
   // prettier-ignore
-  | (qux1&qux2);
+  | qux1&qux2;
 
 export type b =
   // foo
   | (foo1 & foo2)
   // bar
   | (bar1 & bar2)
   // prettier-ignore
-  | (qux1&qux2)
+  | qux1&qux2
   // baz
   | (baz1 & baz2);
 
 export type c =
   // prettier-ignore
-  | (foo1&foo2)
+  | foo1&foo2
   // bar
   | (bar1 & bar2)
   // qux
   | (qux1 & qux2);
```

---

title: Normalizing Union Type Formatting - TypeScript
description: Demonstrates how to normalize the formatting of single-type definitions in TypeScript.  This improves code readability by ensuring consistent spacing and line breaks within type declarations.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_2

language: diff
code:
```
-type A1 /* 2 */ = /* 1 */ /* 3 */ /* 4 */ {
-  key: string;
-};
+type A1 =
+  /* 1 */ /* 2 */
+  /* 3 */ /* 4 */ {
+    key: string;
+  };
```

---

title: Standardizing Union Type Parens - TypeScript
description: Illustrates how to standardize parenthesis for complex union types and type aliases in TypeScript.  This ensures consistent formatting, making the code more readable and maintainable.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_3

language: diff
code:
```
 export type A =
   | aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
   | bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;
 
 export type B =
   | aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
   | bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;
 
 export type C =
   | aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
   | bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;
 
 export type D =
   | aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
   | bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;
 
 export type Multi = (string | number)[];
 
 function f(): string | number {}
 
 var x: string | number;
 var y: string | number;
 
 class Foo<T extends string | number> {}
 
 interface Interface {
   i: (X | Y) & Z;
   j: Partial<X | Y>;
 }
 
 type State = {
   sharedProperty: any;
 } & (
   | { discriminant: "FOO"; foo: any }
   | { discriminant: "BAR"; bar: any }
   | { discriminant: "BAZ"; baz: any }
 );
 
 const foo1 = [abc, def, ghi, jkl, mno, pqr, stu, vwx, yz] as (
   | string
   | undefined
 )[];
 
 const foo2: (
   | AAAAAAAAAAAAAAAAAAAAAA
   | BBBBBBBBBBBBBBBBBBBBBB
   | CCCCCCCCCCCCCCCCCCCCCC
   | DDDDDDDDDDDDDDDDDDDDDD
 )[] = [];
 
 const foo3: keyof (
   | AAAAAAAAAAAAAAAAAAAAAA
   | BBBBBBBBBBBBBBBBBBBBBB
   | CCCCCCCCCCCCCCCCCCCCCC
   | DDDDDDDDDDDDDDDDDDDDDD
 ) = bar;
 
 const foo4:
   | foo
   | (
       | AAAAAAAAAAAAAAAAAAAAAA
       | BBBBBBBBBBBBBBBBBBBBBB
       | CCCCCCCCCCCCCCCCCCCCCC
       | DDDDDDDDDDDDDDDDDDDDDD
     ) = bar;
 
 let a1: C;
 let a2: C;
 let a3: C;
 let a4: C;
 let a5: C;
 let a6: /*1*/ C;
 let a7: /*1*/ C;
 let a8: /*1*/ C;
 let a9: /*1*/ C;
 let a10: /*1*/ /*2*/ C;
 let a11: /*1*/ /*2*/ C;
 
 let aa1: /*1*/ /*2*/ C | D;
 let aa2: /*1*/ /*2*/ C | /*3*/ D;
 let aa3: /*1*/ /*2*/ C | /*3*/ D /*4*/;
 
 type A1 = C;
 type A2 = C;
 type A3 = C;
 type A4 = C;
 type A5 = C;
-type A6 /*1*/ = C;
-type A7 /*1*/ = C;
-type A8 /*1*/ = C;
-type A9 /*1*/ = C;
-type A10 /*1*/ = /*2*/ C;
-type A11 /*1*/ = /*2*/ C;
-type A12 /*1*/ = C;
+type A6 = /*1*/ C;
+type A7 = /*1*/ C;
+type A8 = /*1*/ C;
+type A9 = /*1*/ C;
+type A10 = /*1*/ /*2*/ C;
+type A11 = /*1*/ /*2*/ C;
+type A12 = /*1*/ C;
 type A13 = /*1*/ C;
 
 type Aa1 = /*1*/ /*2*/ C | D;
 type Aa2 = /*1*/ /*2*/ C | /*3*/ D;
 type Aa3 = /*1*/ /*2*/ C | /*3*/ D /*4*/;
 
 type C1 = /*1*/ a | b;
 type C2 = /*1*/ a | b;
 type C3 = /*1*/ a | b;
-type C4 /*1*/ = a | b;
+type C4 = /*1*/ a | b;
 type C5 = /*1*/ a | b;
 type C6 /*0*/ = /*1*/ a | b;
 
 type Ctor = (new () => X) | Y;
```

---

title: Formatting Arrays with Numbers and Comments - Diff
description: Illustrates how Biome handles arrays containing numbers with associated comments. The diff showcases formatting changes, focusing on the placement and alignment of numbers and comments within the array.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_1

language: diff
code:
```
 const lazyCatererNumbers = [
   1, 2, 4, 7, 11, 16, 22, 29, 37, 46, 56, 67, 79, 92, 106, 121, 137, 154, 172,
   191, 211, 232, 254, 277, 301, 326, 352, 379, 407, 436, 466 /*block*/,
   // line
-  497, 529, 562, 596, 631, 667, 704, 742, 781, 821, 862, 904, 947, 991, 1036,
-  1082, 1129, 1177, 1226,
+  497,
+  529, 562, 596, 631, 667, 704, 742, 781, 821, 862, 904, 947, 991, 1036, 1082,
+  1129, 1177, 1226,
   // line 2
-  1276, 1327, 1379,
+  1276,
+  1327, 1379,
 ];
```

---

title: Formatting Numeric Arrays With Negative Values - Diff
description: Demonstrates how Biome formats numeric arrays containing negative values and comments. The diff highlights changes in formatting, specifically line breaks and alignment of negative numbers within the array.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_2

language: diff
code:
```
 const numbers1 = [
   -2017, -506252, -744011292, -7224, -70.4, -83353.6, -708.4, -174023963.52,
   -40385,
   // comment1
-  -380014, -253951682, -728, -15.84, -2058467564.56, -43, -33, -85134845,
-  -67092, -1, -78820379, -2371.6, -16, 7,
+  -380014,
+  -253951682, -728, -15.84, -2058467564.56, -43, -33, -85134845, -67092, -1,
+  -78820379, -2371.6, -16, 7,
   // comment2
-  -62454, -4282239912, -10816495.36, 0.88, -100622682, 8.8, -67087.68000000001,
+  -62454,
+  -4282239912, -10816495.36, 0.88, -100622682, 8.8, -67087.68000000001,
   -3758276, -25.5211, -54, -1184265243, -46073628, -280423.44, -41833463,
   -27961.12, -305.36, -199875.28,
 ];
 
 const numbers2 = [
   -234,
   -342, // comment3
   -223,
   -333333.33,
   12345,
 ];
```

---

title: Formatting Loops with Numeric Literals - Diff
description: Demonstrates how Biome formats `for...of` loops that iterate over arrays containing numeric literals. The diff highlights changes in formatting, specifically line breaks and alignment of the numeric literals within the array.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_3

language: diff
code:
```
 {
   for (const srcPath of [src, `${src}.js`, `${src}/index`, `${src}/index.js`]) {
   }
 }
 {
   for (const srcPath of [123, 123_123_123, 123_123_123_1, 13_123_3123_31_43]) {
   }
 }
 {
-  for (const srcPath of [123, 123_123_123, 123_123_123_1, 13_123_3123_31_432]) {
+  for (const srcPath of [
+    123, 123_123_123, 123_123_123_1, 13_123_3123_31_432,
+  ]) {
   }
 }
 {
   for (const srcPath of [
     123, 123_123_123, 123_123_123_1, 13_123_3123_31_4321,
   ]) {
   }
 }
```

---

title: Diffing Chain Expression Test
description: Illustrates the changes in formatting for chain expressions. The code shows how optional chaining (`?.`) interacts with member access and function calls.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_0

language: diff
code:
```
-(a?.b).c;
-(a?.()).b;
+a?.b.c;
+a?.().b;
 
-(a?.b)();
-(a?.())();
+a?.b();
+a?.()();
 
 new (a?.b)();
 new (a?.())();
```

---

title: Diffing Closure Typecast
description: Demonstrates the changes in how closure type casts are handled in the code. The code shows how `@satisfies` is used to specify the type of an object.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_1

language: diff
code:
```
-module.exports = /** @satisfies {Record<string, string>} */ ({
+module.exports = /** @satisfies {Record<string, string>} */ {
  hello: 1337,
-});
+};
```

---

title: Diffing JSDoc Comments Within Objects
description: Illustrates how JSDoc comments are handled when nested within objects in JavaScript. It focuses on preserving the structure and association of JSDoc comments with object properties.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_2

language: diff
code:
```
 {
   {
     {
       {
         {
           {
             {
               o = {
                 /**
                  * A
-                 *//**
+                 */
+                /**
                  * B
                  */
               };
             }
           }
         }
       }
     }
   }
 }
```

---

title: Diffing Trailing JSDoc Comments
description: Demonstrates the handling of trailing JSDoc comments in JavaScript code. It highlights how the code formatter preserves the association between JSDoc comments and the preceding code elements, particularly when dealing with object properties and exports.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_3

language: diff
code:
```
 const CONNECTION_STATUS = (exports.CONNECTION_STATUS = {
   CLOSED: Object.freeze({ kind: "CLOSED" }),
   CONNECTED: Object.freeze({ kind: "CONNECTED" }),
   CONNECTING: Object.freeze({ kind: "CONNECTING" }),
   NOT_CONNECTED: Object.freeze({ kind: "NOT_CONNECTED" }),
 });
 
-/* A comment */ /**
+/* A comment */
+/**
  * A type that can be written to a buffer.
- */ /**
+ */
+/**
  * Describes the connection status of a ReactiveSocket/DuplexConnection.
  * - NOT_CONNECTED: no connection established or pending.
  * - CONNECTING: when `connect()` has been called but a connection is not yet
  *   established.
  * - CONNECTED: when a connection is established.
  * - CLOSED: when the connection has been explicitly closed via `close()`.
  * - ERROR: when the connection has been closed for any other reason.
- */ /**
+ */
+/**
  * A contract providing different interaction models per the [ReactiveSocket protocol]
  * (https://github.com/ReactiveSocket/reactivesocket/blob/master/Protocol.md).
- */ /**
+ */
+/**
  * A single unit of data exchanged between the peers of a `ReactiveSocket`.
  */
```

---

title: Diffing Tagged Template Literals With Comments
description: Demonstrates how comments are handled within tagged template literals in JavaScript. It shows how comments are positioned relative to the tag function and the template string.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_5

language: diff
code:
```
 foo``; // comment
 
 foo // comment
 ``;
 
 foo // comment
 `
 `;
 
-foo/* comment */ `
+foo /* comment */`
 `;
 
-foo/* comment */ `
+foo /* comment */`
 `;
```

---

title: Diffing Conditional Statements With Comments
description: Illustrates how comments are handled within conditional (ternary) expressions in JavaScript. It demonstrates various comment placements, including comments before, after, and within the conditional parts, and shows how they are preserved during code formatting.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_6

language: diff
code:
```
 var inspect =
   4 === util.inspect.length
     ? // node <= 0.8.x
       function (v, colors) {
         return util.inspect(v, void 0, void 0, colors);
       }
     : // node > 0.8.x
       function (v, colors) {
         return util.inspect(v, { colors: colors });
       };
 
 var inspect =
   4 === util.inspect.length
     ? // node <= 0.8.x
       function (v, colors) {
         return util.inspect(v, void 0, void 0, colors);
       }
     : // node > 0.8.x
       function (v, colors) {
         return util.inspect(v, { colors: colors });
       };
 
 const extractTextPluginOptions = shouldUseRelativeAssetPaths
   ? // Making sure that the publicPath goes back to to build folder.
     { publicPath: Array(cssFilename.split("/").length).join("../") }
   : {};
 
 const extractTextPluginOptions2 = shouldUseRelativeAssetPaths
   ? // Making sure that the publicPath goes back to to build folder.
     { publicPath: Array(cssFilename.split("/").length).join("../") }
   : {};
 
 const extractTextPluginOptions3 = shouldUseRelativeAssetPaths // Making sure that the publicPath goes back to to build folder.
   ? { publicPath: Array(cssFilename.split("/").length).join("../") }
   : {};
 
 const { configureStore } =
   process.env.NODE_ENV === "production"
     ? require("./configureProdStore") // a
     : require("./configureDevStore"); // b
 
 test /* comment
   comment
       comment
 */
   ? foo
   : bar;
 
 test
   ? /* comment
           comment
     comment
           comment
   */
     foo
   : bar;
 
 test
   ? /* comment
        comment
        comment
        comment
     */
     foo
   : test
     ? /* comment
   comment
     comment */
       foo
     : bar;
 
 test ? /* comment */ foo : bar;
 
 test
   ? foo
   : /* comment
          comment
      comment
            comment
     */
     bar;
 
 test
   ? foo
   : /* comment
          comment
      comment
            comment
       A newline will be added after this comment, unfortunately - but it can be removed manually, see next statement.
     */
     test
     ? foo
     : /* comment
   comment
     comment
    */
       bar;
 
 // It is at least possible to delete the extra newline that was
 // unfortunately added before the second condition above:
 test
-  ? foo /* comment
+  ? foo
+  : /* comment
          comment
      comment
            comment
     */
-  : test
+    test
     ? foo
     : /* comment
   comment
     comment
    */
       bar;
 
 test ? foo : /* comment */ bar;
 
 test
   ? test /* c
 c */
     ? foo
     : bar
   : bar;
```

---

title: Formatting Using Binding with Escaped Characters
description: Illustrates how to declare a `using` binding with escaped unicode characters for variable names. The code snippet shows the difference between using a standard variable name and its unicode escaped version. This can be useful in cases where variable names need to adhere to specific character set requirements or to avoid naming conflicts.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_0

language: diff
code:
```
 {
```

---

title: Assigning Object Property with Assignment Expression
description: Demonstrates assigning a value to an object property using an assignment expression within an object literal. The code modifies the `resource` property of `this` and uses the result as the key for a new property in object `a`.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_0

language: diff
code:
```
 a = {
-  [(this.resource = resource)]: 1,
+  [this.resource = resource]: 1,
 };
```

---

title: Parenthesizing Optional Chaining Assignment
description: Demonstrates that the code adds parentheses around an optional chaining expression on the left-hand side of an assignment. This ensures correct operator precedence and avoids potential syntax errors when assigning to a property accessed via optional chaining.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_2

language: diff
code:
```
-a?.b = c;
+(a?.b) = c;
```

---

title: Normalizing Variable Assignment Spacing - JavaScript
description: Normalizes the spacing in variable assignments, ensuring consistency and readability. This example shows how multiple assignments on a single line are adjusted to adhere to a uniform formatting style.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_1

language: diff
code:
```
-foo = 1.0000;bar = 1.0;
-baz = 1.0;
+foo = 1.0000;bar = 1.0;baz=1.0000;
```

---

title: Removing Obsolete Code Blocks With Comments - JavaScript
description: Removes an obsolete code block that is now commented out, cleaning up the codebase. Removes the commented `MSG_GENERIC_OPERATION_FAILURE_BODY_2` constant, improving code clarity.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_9

language: diff
code:
```
 export const MSG_GENERIC_OPERATION_FAILURE_BODY_1 =
   goog.getMsg("That's all we know");
 
-export const MSG_GENERIC_OPERATION_FAILURE_BODY_2 =
-  goog.getMsg("That's all we know");
+// FIXME
+// TODO: reformat issue
+// export const MSG_GENERIC_OPERATION_FAILURE_BODY_2 =
+//   goog.getMsg("That's all we know");
```

---

title: Addressing Formatting Issues In Switch Case - JavaScript
description: Addresses formatting issues within a switch case by removing a commented out section. This improves code readability and reduces clutter.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_10

language: diff
code:
```
 switch (4) {
   default: // comment4
     // comment4a
     break; // comment4b
 }
 
-switch (5) {
-  default: // comment5
-    // comment5a
-    foo();
-    bar(); //comment5b
-    break; // comment5c
-}
+// FIXME
+// TODO: reformat issue
+// switch(5){default: // comment5
+// // comment5a
+// foo();bar();//comment5b
+// break;// comment5c
+// }
```

---

title: Simplifying Function Calls With Ternary Operators - JavaScript
description: Simplifies a function call involving a ternary operator. Improves code conciseness and readability by ensuring proper alignment and spacing of the ternary operator's components.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_11

language: diff
code:
```
 fn(
   bifornCringerMoshedPerplexSawder,
   askTrovenaBeenaDependsRowans,
   glimseGlyphsHazardNoopsTieTie === averredBathersBoxroomBuggyNurl &&
-    anodyneCondosMalateOverateRetinol
+  anodyneCondosMalateOverateRetinol
     ? annularCooeedSplicesWalksWayWay
     : kochabCooieGameOnOboleUnweave,
 );
// TODO(rattrayalex): try to indent consequent/alternate here.
```

---

title: Throwing TypeErrors with Default Parameters
description: Demonstrates how to throw a `TypeError` as a default parameter value in a function definition, ensuring that the function will throw an error if the argument is not provided. Also shows throwing errors in other expressions.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_1

language: javascript
code:
```
function save(filename = throw new TypeError("Argument required")
)
{
}
 
lint(ast, {
  with: () => throw new Error("avoid using 'with' statements.")
});
 
function getEncoder(encoding) {
  const encoder = encoding === "utf8" ? new UTF8Encoder()
                : encoding === "utf16le" ? new UTF16Encoder(false)
                : encoding === "utf16be" ? new UTF16Encoder(true)
                :
  throw new Error("Unsupported encoding");
}
 
class Product {
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value ||
    throw new Error("Invalid value");
  }
}
```

---

title: Formatting Curried Arrow Functions
description: Illustrates the formatting of curried arrow functions, including those returning objects and using implicit returns. The diff demonstrates how the formatter handles line breaks and indentation in complex curried function scenarios.
source: crates/biome_js_formatter/report-es2015.md#_snippet_3

language: diff
code:
```
 const fn1 = (a) => 3;
 const fn2 = (a) => (b) => 3;
 const fn3 = (a) => (b) => (c) => 3;
 const fn4 = (a) => (b) => (c) => (d) => 3;
 const fn5 = (a) => (b) => (c) => (d) => (e) => 3;
 const fn6 = (a) => (b) => (c) => (d) => (e) => (g) => 3;
 const fn7 = (a) => (b) => (c) => (d) => (e) => (g) => (f) => 3;
 
 const fn8 = (a) => ({ foo: bar, bar: baz, baz: foo });
 const fn9 = (a) => (b) => ({ foo: bar, bar: baz, baz: foo });
 const fn10 = (a) => (b) => (c) => ({ foo: bar, bar: baz, baz: foo });
 const fn11 = (a) => (b) => (c) => (d) => ({ foo: bar, bar: baz, baz: foo });
 const fn12 = (a) => (b) => (c) => (d) => (e) => ({
   foo: bar,
   bar: baz,
   baz: foo,
 });
 const fn13 = (a) => (b) => (c) => (d) => (e) => (g) => ({
   foo: bar,
   bar: baz,
   baz: foo,
 });
 const fn14 = (a) => (b) => (c) => (d) => (e) => (g) => (f) => ({
   foo: bar,
   bar: baz,
   baz: foo,
 });
 
 const curryTest =
   (argument1) =>
   (argument2) =>
   (argument3) =>
   (argument4) =>
   (argument5) =>
   (argument6) =>
   (argument7) =>
   (argument8) =>
   (argument9) =>
   (argument10) =>
   (argument11) =>
   (argument12) => ({
     foo: argument1,
     bar: argument2,
   });
 
 let curryTest2 =
   (argument1) =>
   (argument2) =>
   (argument3) =>
   (argument4) =>
   (argument5) =>
   (argument6) =>
   (argument7) =>
   (argument8) =>
   (argument9) =>
   (argument10) =>
   (argument11) =>
   (argument12) => {
     const foo = "foo";
     return foo + "bar";
   };
 
 curryTest2 =
   (argument1) =>
   (argument2) =>
   (argument3) =>
   (argument4) =>
   (argument5) =>
   (argument6) =>
   (argument7) =>
   (argument8) =>
   (argument9) =>
   (argument10) =>
   (argument11) =>
   (argument12) => {
     const foo = "foo";
     return foo + "bar";
   };
 
 throw (argument1) =>
   (argument2) =>
   (argument3) =>
   (argument4) =>
   (argument5) =>
   (argument6) =>
   (argument7) =>
   (argument8) =>
   (argument9) =>
   (argument10) =>
   (argument11) =>
   (argument12) => {
     const foo = "foo";
     return foo + "bar";
   };
 
 foo(
   (argument1) =>
     (argument2) =>
     (argument3) =>
     (argument4) =>
     (argument5) =>
     (argument6) =>
     (argument7) =>
     (argument8) =>
     (argument9) =>
     (argument10) =>
     (argument11) =>
     (argument12) =>
       3,
 );
 
-foo(
-  (argument1) =>
-    (argument2) =>
-    (argument3) =>
-    (argument4) =>
-    (argument5) =>
-    (argument6) =>
-    (argument7) =>
-    (argument8) =>
-    (argument9) =>
-    (argument10) =>
-    (argument11) =>
-    (argument12) => ({
-      foo: bar,
-      bar: baz,
-      baz: foo,
-    }),
-);
+foo((argument1) =>
+  (argument2) =>
+  (argument3) =>
+  (argument4) =>
+  (argument5) =>
+  (argument6) =>
+  (argument7) =>
+  (argument8) =>
+  (argument9) =>
+  (argument10) =>
+  (argument11) =>
+  (argument12) => ({
+    foo: bar,
+    bar: baz,
+    baz: foo,
+  }));
 
-foo(
-  (argument1) =>
-    (argument2) =>
-    (argument3) =>
-    (argument4) =>
-    (argument5) =>
-    (argument6) =>
-    (argument7) =>
-    (argument8) =>
-    (argument9) =>
-    (argument10) =>
-    (argument11) =>
-    (argument12) => {
-      const foo = "foo";
-      return foo + "bar";
-    },
-);
+foo((argument1) =>
+  (argument2) =>
+  (argument3) =>
+  (argument4) =>
+  (argument5) =>
+  (argument6) =>
+  (argument7) =>
+  (argument8) =>
+  (argument9) =>
+  (argument10) =>
+  (argument11) =>
+  (argument12) => {
+    const foo = "foo";
+    return foo + "bar";
+  });
 
 (
   (argument1) =>
   (argument2) =>
   (argument3) =>
   (argument4) =>
   (argument5) =>
   (argument6) =>
   (argument7) =>
   (argument8) =>
   (argument9) =>
   (argument10) =>
   (argument11) =>
   (argument12) =>
     3
 )(3);
 
 bar(
-  foo(
-    (argument1) =>
-      (argument2) =>
-      (argument3) =>
-      (argument4) =>
-      (argument5) =>
-      (argument6) =>
-      (argument7) =>
-      (argument8) =>
-      (argument9) =>
-      (argument10) =>
-      (argument11) =>
-      (argument12) => ({
-        foo: bar,
-        bar: baz,
-      }),
-  ),
+  foo((argument1) =>
+    (argument2) =>
+    (argument3) =>
+    (argument4) =>
+    (argument5) =>
+    (argument6) =>
+    (argument7) =>
+    (argument8) =>
+    (argument9) =>
+    (argument10) =>
+    (argument11) =>
+    (argument12) => ({
+      foo: bar,
+      bar: baz,
+    })),
 );
 
 const baaaz =
   (aaaaa1, bbbbb1) =>
   (aaaaa2, bbbbb2) =>
   (aaaaa3, bbbbb3) =>
   (aaaaa4, bbbbb4) => ({
     foo: bar,
   });
 
 new Fooooooooooooooooooooooooooooooooooooooooooooooooooo(
   (action) => (next) => (next) => (next) => (next) => (next) => (next) =>
     dispatch(action),
 );
 
 foo?.Fooooooooooooooooooooooooooooooooooooooooooooooooooo(
   (action) => (next) => (next) => (next) => (next) => (next) => (next) =>
     dispatch(action),
 );
 
 foo((action) => (action) => action);
```

---

title: Formatting Import Statements With Curried Arrow Functions
description: Demonstrates how to format import statements with complex curried arrow functions. The diff shows the change of how to format the `import` statement.
source: crates/biome_js_formatter/report-es2015.md#_snippet_4

language: diff
code:
```
+import((argument1) =>
+  (argument2) =>
+  (argument3) =>
+  (argument4) =>
+  (argument5) =>
+  (argument6) =>
+  (argument7) =>
+  (argument8) =>
+  (argument9) =>
+  (argument10) =>
+  (argument11) =>
+  (argument12) => {
+    const foo = "foo";
+    return foo + "bar";
+  });
```

---

title: Defining Curried Functions with Rest Arguments
description: Demonstrates defining curried functions that accept a fixed number of initial arguments, followed by a variable number of rest arguments using the `...` syntax.
source: crates/biome_js_formatter/report-es2015.md#_snippet_5

language: javascript
code:
```
const foobar =
  (argumentOne, argumentTwo, argumentThree) =>
  (...restOfTheArguments) => {
    return "baz";
  };

const foobaz =
  (argumentOne, argumentTwo, argumentThree) => (restOfTheArguments123, j) => {
    return "baz";
  };

const makeSomeFunction = (services = { logger: null }) => (a, b, c) =>
  services.logger(a, b, c);

const makeSomeFunction2 =
  (
    services = {
      logger: null,
    },
  ) =>
  (a, b, c) =>
    services.logger(a, b, c);
```

---

title: Illustrating JSDoc Nesting
description: Demonstrates how JSDoc comments can be nested within JavaScript objects, illustrating the correct placement and formatting of these comments. It also shows how trailing comments are handled and nested.
source: crates/biome_js_formatter/report-es2015.md#_snippet_0

language: javascript
code:
```
 {   {     {       {         {           {             {               o = {                 /**                  * A                  *//**                  * B                  */               };             }           }         }       }     }   } }
```

---

title: Handling Trailing JSDocs
description: Illustrates how trailing JSDoc comments are handled in object literals and function definitions. The example demonstrates the proper formatting and placement of these comments.
source: crates/biome_js_formatter/report-es2015.md#_snippet_1

language: javascript
code:
```
const issues = {
  see: "#7724 and #12653",
  /** Trailing comment 1 (not nestled as both comments should be multiline for that) */ /**
   * Trailing comment 2
   */
};

/**
 * @template T
 * @param {Type} type
 * @param {T} value
 * @return {Value}
 *//**
 * @param {Type} type
 * @return {Value}
 */
function value(type, value) {
  if (arguments.length === 2) {
    return new ConcreteValue(type, value);
  } else {
    return new Value(type);
  }
}

/** Trailing nestled comment 1
 *//** Trailing nestled comment 2
 *//** Trailing nestled comment 3
 */
```

---

title: Handling Multi-Line Comments
description: Demonstrates various ways to place multi-line comments on the same line within JavaScript code.  It shows how comments are rendered when placed before, after, and between code elements.
source: crates/biome_js_formatter/report-es2015.md#_snippet_2

language: javascript
code:
```
/*========= All on same line =========*/
a;
/*1*/ /*2*/ /*3*/
b;

a; /*1*/ /*2*/ /*3*/
b;

a;
/*1*/ /*2*/ /*3*/ b;

a;
/*
 1*/ /*2*/ /*3
  */
b;

a; /*
 1*/ /*2*/ /*3
  */
b;

a; /*
 1*/ /*2*/ /*3
  */ b;

/*========= First two on same line =========*/
a;
/*1*/ /*2*/
/*3*/
b;

a; /*1*/ /*2*/
/*3*/
b;

a;
/*1*/ /*2*/
/*3*/ b;

a;
/*
 1*/ /*2*/
/*3
  */
b;

a; /*
 1*/ /*2*/
/*3
  */
b;

a; /*
 1*/ /*2*/
/*3
  */ b;

/*========= Last two on same line =========*/
a;
/*1*/
/*2*/ /*3*/
b;

a; /*1*/
/*2*/ /*3*/
b;

a;
/*1*/
/*2*/ /*3*/ b;

a;
/*
 1*/
/*2*/ /*3
  */
b;

a; /*
 1*/
/*2*/ /*3
  */
b;

a; /*
 1*/
/*2*/ /*3
  */ b;
```

---

title: Handling Trailing JSDocs on Constants
description: Illustrates the formatting of trailing JSDoc comments on constant declarations. This example highlights the correct placement and structure of these comments to ensure proper documentation and code readability.
source: crates/biome_js_formatter/report-es2015.md#_snippet_4

language: javascript
code:
```
const CONNECTION_STATUS = (exports.CONNECTION_STATUS = {
  CLOSED: Object.freeze({ kind: "CLOSED" }),
  CONNECTED: Object.freeze({ kind: "CONNECTED" }),
  CONNECTING: Object.freeze({ kind: "CONNECTING" }),
  NOT_CONNECTED: Object.freeze({ kind: "NOT_CONNECTED" }),
});

/* A comment */
/**
 * A type that can be written to a buffer.
 */
/**
 * Describes the connection status of a ReactiveSocket/DuplexConnection.
 * - NOT_CONNECTED: no connection established or pending.
 * - CONNECTING: when `connect()` has been called but a connection is not yet
 *   established.
 * - CONNECTED: when a connection is established.
 * - CLOSED: when the connection has been explicitly closed via `close()`.
 * - ERROR: when the connection has been closed for any other reason.
 */
/**
 * A contract providing different interaction models per the [ReactiveSocket protocol]
 * (https://github.com/ReactiveSocket/reactivesocket/blob/master/Protocol.md).
 */
/**
 * A single unit of data exchanged between the peers of a `ReactiveSocket`.
 */
```

---

title: Handling Comments in `if` Statements
description: Demonstrates how comments are handled within `if` and `else if` statements. It showcases different comment styles (single-line and multi-line) and their placement relative to expressions and code blocks within the conditional statements in `js/if/expr_and_same_line_comments.js`.
source: crates/biome_js_formatter/report-es2015.md#_snippet_0

language: javascript
code:
```
 if (a === 0) doSomething(); // comment A1
 else if (a === 1) doSomethingElse(); // comment B1
 else if (a === 2) doSomethingElse(); // comment C1
 
 if (a === 0) doSomething(); /* comment A2 */
 else if (a === 1) doSomethingElse(); /* comment B2 */
 else if (a === 2) doSomethingElse(); /* comment C2 */
 
 if (a === 0) expr; // comment A3
 else if (a === 1) expr; // comment B3
 else if (a === 2) expr; // comment C3
 
 if (a === 0) expr; /* comment A4 */
 else if (a === 1) expr; /* comment B4 */
 else if (a === 2) expr; /* comment C4 */
 
 if (a === 0)
   looooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong; // comment A5
 else if (a === 1)
   looooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong; // comment B5
 else if (a === 2)
   looooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong; // comment C5
 
 function a() {
   if (a) return /* comment 6a */;
   else return 2;
 
   if (a) return 1 /* comment 6b */;
   else return 2;
 
   if (a) throw e /* comment 6d */;
   else return 2;
 
   // TODO[@fisker]: fix this
   // if (a) var a = 1; /* comment 6e */
   // else return 2;
 
   if (a)
    if (b);/* comment 6f */
    else return 2;
 }
```

---

title: Handling Function Bodies In Mode Break
description: Demonstrates how function bodies are formatted in "mode break" scenarios within JavaScript code, specifically when dealing with conditional expressions or long argument lists, as seen in `js/last-argument-expansion/function-body-in-mode-break.js`. It illustrates how the code is broken into multiple lines to enhance readability.
source: crates/biome_js_formatter/report-es2015.md#_snippet_5

language: javascript
code:
```
 fs.readdirSync(suiteLoc).forEach(function (testName) {
  (skip
    ? it.skip
    : it)(testName, buildTest(binName, testName, opts), 2_000_000);
 });
 
 {
  (skip ? it.skip : it)(
    testName,
    buildTest(binName, testName, opts),
    2_000_000,
  );
 }
```

---

title: Formatting String Literals
description: Demonstrates the original formatting of a multi-line string literal using `goog.getMsg`. The code snippet shows how a reformatting issue arises with single quotes inside a multi-line string.
source: crates/biome_js_formatter/report-es2015.md#_snippet_3

language: diff
code:
```
+// FIXME
+// TODO: reformat issue
+// export const MSG_GENERIC_OPERATION_FAILURE_BODY_2 =
+//   goog.getMsg("That's all we know");
```

language: diff
code:
```
 export const MSG_GENERIC_OPERATION_FAILURE_BODY_1 =
   goog.getMsg("That's all we know");
 
-export const MSG_GENERIC_OPERATION_FAILURE_BODY_2 =
-  goog.getMsg("That's all we know");
```

---

title: Formatting Switch Statements With Comments
description: Illustrates a formatting issue in a `switch` statement containing comments. The original and the formatted versions are provided. The snippet shows how the formatter handles comments within `switch` blocks.
source: crates/biome_js_formatter/report-es2015.md#_snippet_4

language: diff
code:
```
 switch (1) {
   default: // comment1
 }
 
 switch (2) {
   default: // comment2
   //comment2a
 }
 
 switch (3) {
   default: // comment3
     break; // comment3a
 }
 
 switch (4) {
   default: // comment4
     // comment4a
     break; // comment4b
 }
```

language: diff
code:
```
 switch (5) {
-  default: // comment5
-    // comment5a
-    foo();
-    bar(); //comment5b
-    break; // comment5c
-}        
```

language: diff
code:
```
+// FIXME
+// TODO: reformat issue
+// switch(5){default: // comment5
+// // comment5a
+// foo();bar();//comment5b
+// break;// comment5c
+// }
```

---

title: Formatting Angularjs Inject Functions
description: Illustrates the formatting of `inject` functions in AngularJS tests. It shows how the formatter handles dependency injection and the arrangement of arguments.
source: crates/biome_js_formatter/report-es2015.md#_snippet_6

language: diff
code:
```
 beforeEach(inject(($fooService, $barService) => {
   // code
 }));
 
 afterAll(inject(($fooService, $barService) => {
   console.log("Hello");
 }));
 
 it("should create the app", inject(($fooService, $barService) => {
   //code
 }));
 
 it("does something really long and complicated so I have to write a very long name for the test", inject(() => {
   // code
 }));
 
-it("does something really long and complicated so I have to write a very long name for the test", inject((
-  $fooServiceLongName,
-  $barServiceLongName,
-) => {
+it("does something really long and complicated so I have to write a very long name for the test", inject(($fooServiceLongName, $barServiceLongName) => {
   // code
 }));
 
 /*
  * isTestCall(parent) should only be called when parent exists
  * and parent.type is CallExpression. This test makes sure that
  * no errors are thrown when calling isTestCall(parent)
  */
 function x() {
   inject(() => {});
 }
```

---

title: Formatting Throw Expressions
description: Demonstrates the formatting of throw expressions in various contexts, such as default parameter values, arrow functions, and ternary operators. It highlights how the formatter handles line breaks and indentation around throw statements.
source: crates/biome_js_formatter/report-es2015.md#_snippet_7

language: diff
code:
```
-function save(filename = throw new TypeError("Argument required")) {}
+function save(filename = throw new TypeError("Argument required")
+)
+{
+}
 
 lint(ast, {
-  with: () => throw new Error("avoid using 'with' statements."),
+  with: () => throw new Error("avoid using 'with' statements.")
 });
 
 function getEncoder(encoding) {
-  const encoder =
-    encoding === "utf8"
-      ? new UTF8Encoder()
-      : encoding === "utf16le"
-        ? new UTF16Encoder(false)
-        : encoding === "utf16be"
-          ? new UTF16Encoder(true)
-          : throw new Error("Unsupported encoding");
+  const encoder = encoding === "utf8" ? new UTF8Encoder()
+                : encoding === "utf16le" ? new UTF16Encoder(false)
+                : encoding === "utf16be" ? new UTF16Encoder(true)
+                :
+  throw new Error("Unsupported encoding");
 }
 
 class Product {
   get id() {
     return this._id;
   }
   set id(value) {
-    this._id = value || throw new Error("Invalid value");
+    this._id = value ||
+    throw new Error("Invalid value");
   }
 }
```

---

title: Running ARIA Data Generation
description: Illustrates how to run the `generate-aria-data.js` script to extract data from an ARIA specification. The command takes the name and version of the ARIA specification as input and writes the extracted data to a specified JSON file. This approach is necessary because ARIA specifications are in a semi-structured representation.
source: packages/aria-data/README.md#_snippet_0

language: shell
code:
```
node generate-aria-data.js wai-aria-1.2 >| wai-aria-1-2.json
```

---

title: Profiling Heap Usage with dhat
description: Demonstrates how to profile heap usage using `dhat`.  This command runs the `xtask_bench` crate with the `dhat-heap` feature enabled, in release mode with debug information, to collect heap allocation data.
source: xtask/bench/README.md#_snippet_4

language: bash
code:
```
cargo run -p xtask_bench --features dhat-heap --release-with-debug
```

---

title: Formatting Function Calls
description: Illustrates how to format function calls with line breaks and spacing. This helps to maintain readability, especially with multiple parameters.
source: crates/biome_js_formatter/report.md#_snippet_4

language: diff
code:
```
 function a(
 ){
-  a();
-  b();
-  c();
-  d();
+a (
+);
+b();
+c(); d(
+);
+
 }
```

---

title: Formatting Multiple Statements
description: Demonstrates how the formatter handles multiple statements within a limited range. It demonstrates how it formats function calls to fit within specified constraints.
source: crates/biome_js_formatter/report.md#_snippet_5

language: diff
code:
```
 a (
 );
-b (
-);                 c (
-); d(
+b();
+c(); d(
 );
```

---

title: Formatting Property Assignments
description: Illustrates how properties are assigned values with appropriate spacing for readability. The example demonstrates that `baz` which previously had a newline is now inline with `foo` and `bar`.
source: crates/biome_js_formatter/report.md#_snippet_6

language: diff
code:
```
-foo = 1.0000;bar = 1.0;
-baz = 1.0;
+foo = 1.0000;bar = 1.0;baz=1.0000;
 // The range will be 13~26
 // `foo` ends at 13, should not format
 // `bar` ends at 26, should format
```

---

title: Formatting Class Declarations
description: Demonstrates how to format class declarations with proper indentation. This includes proper spacing around class keywords and method declarations.
source: crates/biome_js_formatter/report.md#_snippet_7

language: diff
code:
```
+
+
 class a {
   b() {}
 }
 
-let x;
+let    x
```

---

title: Formatting Function Calls with Parameters
description: Illustrates how to format function calls with multiple parameters for better readability.  It shows the differences in spacing when parameters are arranged on multiple lines.
source: crates/biome_js_formatter/report.md#_snippet_8

language: diff
code:
```
 call(
   1, 2,3
 );
 
 call(1, 2, 3);
 
 call(1, 2, 3);
 
-call(1, 2, 3);
+call(
+  1, 2,3
+);
```

---

title: Formatting Try Catch Blocks
description: Illustrates how `try...catch` blocks are formatted for readability. This includes proper indentation and spacing within the `try` and `catch` blocks.
source: crates/biome_js_formatter/report.md#_snippet_9

language: diff
code:
```
 try {
-  1;
-  if (condition) {
-    body;
-  }
+1;
+if (condition) {
+  body;
+}
 } catch (err) {}
```

---

title: Formatting Tuple and Record Type Assertions - TypeScript
description: Demonstrates the proper formatting for tuple and record type assertions in TypeScript. It highlights the correct syntax and spacing to ensure readability and maintainability when using type assertions.
source: crates/biome_js_formatter/report.md#_snippet_5

language: typescript
code:
```
 breakAfterCast = <PermissionsChecker<any> | undefined>(
   (<any>permissions)[receiverType]
 );
-breakAfterCast = <PermissionsChecker<any> | undefined>(
-  (<any>permissions)(#[receiverType])
-);
+breakAfterCast = <PermissionsChecker<any> | undefined>(<any>permissions)(#[receiverType]);
 
testObjLiteral = <PermissionsChecker<any> | undefined>{ prop1: "myPropVal" };
-testObjLiteral = <PermissionsChecker<any> | undefined>#{ prop1: "myPropVal" };
+testObjLiteral =  <PermissionsChecker<any> | undefined>
+#
+{
+  prop1: "myPropVal";
+}
```

---

title: Formatting Comments Around Empty Statements (JavaScript)
description: Illustrates how Biome and Prettier handle comments around empty statements and arithmetic expressions in JavaScript. It highlights differences in comment placement and line breaking.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_4

language: diff
code:
```
-a; /* a */ // b
-/* c */
-foo; // first
-// second
-// third
-function x() {} // first
-// second
+a; /* a */ /* c */ // b
+
+foo; // first // second // third
+
+function x() {} // first // second
+
 a =
-  b + // 1
-  // 2
-  c + // 3
-  // 4
-  d + // 5
-  /* 6 */
+  b + // 1 // 2
+  c + // 3 // 4
+  d /* 6 */ + // 5
   e; // 7
```

---

title: Handling Comments Without Blocks
description: Demonstrates the proper placement of comments after `continue` and `break` statements within loops, even when blocks are omitted. Ensures comments are correctly associated with the statements, preserving code intent.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_5

language: javascript
code:
```
 for (;;) continue;
 // comment
 
 for (;;) break;
 // comment
 
 for (const f of []) continue;
 // comment
 
 for (const f of []) break;
 // comment
 
 for (const f in {}) continue;
 // comment
 
 for (const f in {}) break;
 // comment
 
 for (;;) continue; // comment
 
 for (;;) break; // comment
 
 for (const f of []) continue; // comment
 
 for (const f of []) break; // comment
 
 for (const f in {}) continue; // comment
 
 for (const f in {}) break; // comment
 
 for (;;) continue; /* comment */
 
 for (;;) break; /* comment */
 
 for (const f of []) continue; /* comment */
 
 for (const f of []) break; /* comment */
 
 for (const f in {}) continue; /* comment */
 
 for (const f in {}) break; /* comment */
 
 for (;;) continue;
 /* comment */
 
 for (;;) break;
 /* comment */
 
 for (const f of []) continue;
 /* comment */
 
 for (const f of []) break;
 /* comment */
 
 for (const f in {}) continue;
 /* comment */
 
 for (const f in {}) break;
 /* comment */
 
-label1: for (;;) continue label1 /* comment */;
+label1: for (;;) continue label1; /* comment */
 
 label1: for (;;) continue label1;
 /* comment */
 
 label1: for (;;) continue label1; // comment
 
 label1: for (;;) continue label1;
 // comment
```

---

title: Improving Readability with Short Ternaries - Javascript
description: Demonstrates several ternary expressions where the consequent branch returns a simple value. Suggests using consistent formatting to make the logic more easily understood.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_2

language: javascript
code:
```
function foo4() {
  return !match || match.length < 5
    ? line
    : match[1] + match[2] + match[3] + match[4];
}

function foo5() {
  return !match || match.length < 5
    ? foo(line)
    : match[1] + match[2] + match[3] + match[4];
}

function foo6() {
  return !match || match.length < 5
    ? linethatisverylongandbreaksthelinehooray
    : match[1] + match[2] + match[3] + match[4];
}

function foo7() {
  return !match || match.length < 5
    ? linethatisverylongandbreaksthelinehoorayjustabitlonger
    : match[1] + match[2] + match[3] + match[4];
}
```

---

title: Refactoring a Try Catch block
description: Shows differences in formatting the contents within a `try...catch` block. Specifically, some linebreaks are removed and the conditional statement is refactored.
source: crates/biome_js_formatter/report-es2015.md#_snippet_7

language: diff
code:
```
 try {
-  1;
-  if (condition) {
-    body;
-  }
+1;
+if (condition) {
+  body;
+}
 }
```

---

title: Adding Vcs Configuration
description: Demonstrates how to configure the `vcs` property within the Rome configuration to integrate with Version Control Systems. The configuration allows enabling/disabling VCS integration, specifying the client, using ignore files, and defining the VCS root.
source: ROME_CHANGELOG.md#_snippet_0

language: text
code:
```
vcs: {
  - `vcs.enabled`, to enable or not the integration;
  - `vcs.clientKind`, the supported clients;
  - `vcs.useIgnoreFile`, to ignore the files/paths inside the file;
  - `vcs.root`, an optional path to the root of the VCS;
}
```

---

title: Enabling Organize Imports in Configuration
description: Illustrates how to enable the experimental `organizeImports` feature in the Rome configuration. The `enabled` option activates the feature, while the `ignore` array specifies files to exclude from import organization.
source: ROME_CHANGELOG.md#_snippet_1

language: json
code:
```
{
  "organizeImports": {
    "enabled": true,
    "ignore": ["trickyFile.js"]
  }
}
```

---

title: Enabling/Disabling Linter Rules
description: Demonstrates how to enable or disable all linter rules, or all rules for a specific group, using the `linter.rules.all` and `linter.rules.[group].all` options in the Rome configuration. The `all` and `recommended` options cannot both be `true` simultaneously.
source: ROME_CHANGELOG.md#_snippet_2

language: json
code:
```
{
  "linter": {
    "rules": {
      "all": true,
      "style" : {
        "all": false
      }
    }
  }
}
```

---

title: Configuring Linter Rules
description: Illustrates how to manually enable linter rules within a `rome.json` configuration file, setting the `useBlockStatements` rule to `warn`.
source: ROME_CHANGELOG.md#_snippet_1

language: json
code:
```
{
  "linter": {
    "rules": {
        "style": {
            "useBlockStatements": "warn"
        }
    }
  }
}
```

---

title: Ignoring Folders and Files Using Unix Shell Style Patterns
description: Demonstrates how to configure Rome to ignore specific folders and files during formatting and linting using Unix shell-style patterns in the `rome.json` configuration file. This allows excluding generated code, test files, or other irrelevant files from Rome's processing.
source: ROME_CHANGELOG.md#_snippet_0

language: json
code:
```
{ "formatter": { "ignore": ["scripts/*.js"] }, "linter": { "ignore": ["src/**.test.{ts,js}"] } }
```

---

title: Enabling Editor Config Loading With Biome Configuration
description: Adds support for loading formatting options from `.editorconfig` files by setting the `formatter.useEditorconfig` option to `true` in `biome.json`.
source: CHANGELOG_v1.md#_snippet_29

language: json
code:
```
{
  "formatter": {
    "useEditorconfig": true
  }
}
```

---

title: Implementing Deserializable with a Custom Visitor
description: Illustrates how to implement `Deserializable` for a `Union` type using a custom visitor. This involves creating a struct implementing `DeserializationVisitor` and handling specific types like `bool` and `str` through the `visit_bool` and `visit_str` methods.
source: crates/biome_deserialize/README.md#_snippet_2

language: rust
code:
```
impl Deserializable for Union {
    fn deserialize(
        ctx: &mut impl DeserializationContext,
        value: &impl DeserializableValue,
        name: &str,
    ) -> Option<Self> {
        // Delegate deserialization to `UnionVisitor`
        value.deserialize(ctx, UnionVisitor, name)
    }
}

struct UnionVisitor;
impl DeserializationVisitor for UnionVisitor {
    type Output = Union;

    // We expect a `bool` or a `str` as data type.
    const EXPECTED_TYPE: DeserializableTypes = DeserializableTypes::BOOL.union(DeserializableTypes::STR);

    // Because we expect a `bool` or a `str`, we have to implement the associated method `visit_bool`.
    fn visit_bool(
        self,
        _ctx: &mut impl DeserializationContext,
        value: bool,
        range: TextRange,
        _name: &str,
    ) -> Option<Self::Output> {
        Some(Union::Bool(value))
    }

    // Because we expect a `bool` or a `str`, we have to implement the associated method `visit_str`.
    fn visit_str(
        self,
        _ctx: &mut impl DeserializationContext,
        value: Text,
        range: TextRange,
        _name: &str,
    ) -> Option<Self::Output> {
        Some(Union::Str(value.text().to_string()))
    }
}
```

---

title: Handling Edge Cases in Ternary Expressions
description: Illustrates specific edge cases and potential improvements in formatting complex ternary expressions. These examples highlight scenarios where code readability can be compromised due to the nesting and length of conditions.
source: crates/biome_js_formatter/report.md#_snippet_1

language: javascript
code:
```
const delayedDataProvider = new Proxy(restProvider, {
  get: (target, name, self) =>
-    name === "then" // as we await for the dataProvider, JS calls then on it. We must trap that call or else the dataProvider will be called with the then method
-      ? self
+    name === "then"
+      ? // as we await for the dataProvider, JS calls then on it. We must trap that call or else the dataProvider will be called with the then method
+        self
      : (resource, params) =>
          new Promise((resolve) =>
            setTimeout(
              () => resolve(restProvider[name](resource, params)),
              500,
            ),
          ),
});

function foo4() {
  return !match || match.length < 5
    ? line
    : match[1] + match[2] + match[3] + match[4];
}

function foo5() {
  return !match || match.length < 5
    ? foo(line)
    : match[1] + match[2] + match[3] + match[4];
}

function foo6() {
  return !match || match.length < 5
    ? linethatisverylongandbreaksthelinehooray
    : match[1] + match[2] + match[3] + match[4];
}

function foo7() {
  return !match || match.length < 5
    ? linethatisverylongandbreaksthelinehoorayjustabitlonger
    : match[1] + match[2] + match[3] + match[4];
}
```

---

title: Formatting Nested Ternary Expressions and Comments
description: Demonstrates cases of nested ternary expressions and comments within ternary conditions. These examples illustrate challenges in maintaining code clarity when comments interact with complex conditional logic.
source: crates/biome_js_formatter/report.md#_snippet_2

language: javascript
code:
```
const badComments = schema.model
  ? schema
  : // If model is an array where the items schema is a referred model then we need to use that
    schema.type === "array"
    ? schema.items
    : schema;

const anotherBadComment = refModel
  ? // If we're in a shared params file then reference the model name directly
    inSharedParamsFile
    ? refModel
    : // If we're not in a shared params file then reference the in-file type
      classRef()
  : // We don't have a model name, use the in-file name
    classRef();
```

---

title: Ignoring Code Formatting with Prettier Ignore
description: Illustrates how to use `// prettier-ignore` to prevent the formatter from modifying specific code blocks. This is useful when the desired formatting deviates from the tool's default style.
source: crates/biome_js_formatter/report.md#_snippet_0

language: javascript
code:
```
// prettier-ignore
(
  @decorator
  class {}
);
```

---

title: Ignoring Code Formatting In Function With Prettier Ignore
description: Demonstrates how to use `// prettier-ignore` and `// eslint-disable-next-line` to disable formatting and linting for a specific line within a function. This is useful when dealing with code that requires a specific structure that linters might flag as an error.
source: crates/biome_js_formatter/report.md#_snippet_1

language: javascript
code:
```
function HelloWorld(x) {
  (
    // prettier-ignore
    // eslint-disable-next-line
    x.a |
    x.b
  ).call(null)
}

function HelloWorld(x) {
  // prettier-ignore
  (
    // eslint-disable-next-line
    x.a |
    x.b
  ).call(null)
}
```

---

title: Ignoring Formatting in Argument List With Prettier Ignore
description: Shows how to use `// prettier-ignore` to prevent the formatter from reformatting arguments passed to a function. This can be important when maintaining specific formatting requirements for arguments.
source: crates/biome_js_formatter/report.md#_snippet_2

language: javascript
code:
```
oneArgument(
  // prettier-ignore
  (0, 1),
);

a =
  // prettier-ignore
  (0, 1);
```

---

title: Ignoring Formatting of Awaited Values With Prettier Ignore
description: Demonstrates using `// prettier-ignore` to disable formatting for expressions involving `await`. This is useful when you need to control the precise formatting around asynchronous operations.
source: crates/biome_js_formatter/report.md#_snippet_3

language: javascript
code:
```
async function foo() {
  (
  	// prettier-ignore
  	// b
	await thing()
).blah
}
```

---

title: Ignoring Formatting of Float Array with Prettier Ignore
description: Demonstrates the usage of `// prettier-ignore` to prevent reformatting of a `Float32Array`. This ensures that the array's specific formatting is preserved.
source: crates/biome_js_formatter/report.md#_snippet_4

language: javascript
code:
```
export default function test() {
  return {
    matrix: // prettier-ignore
      new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
  };
}
```

---

title: Ignoring Sequence Expressions
description: Illustrates how to use `prettier-ignore` comments to prevent formatting of specific sequence expressions. The provided diff shows that the original formatting of the parenthesized sequence expression is preserved when the `prettier-ignore` comment is used.
source: crates/biome_js_formatter/report.md#_snippet_10

language: diff
code:
```
-+(
-  // prettier-ignore
-  ((
++// prettier-ignore
+(    (
       first
     )
     ,
     (
       last
-    ))
-);
```

---

title: Formatting Parenthesized Expressions
description: Demonstrates how to format parenthesized expressions with comments. The code shows that the formatter preserves the comments around the expression, while correctly formatting the expression within the parentheses.
source: crates/biome_js_formatter/report.md#_snippet_11

language: diff
code:
```
 console.log(
   /* 1 */
+
   /* 2 */
+
   /* 3 */
   (first,
   /* 4 */
   /* 5 */
   /* 6 */
+
   /* 7 */
   last),
   /* 8 */
   /* 9 */
   /* 10 */
 );
```

---

title: Avoiding Unnecessary Code Trapping - Javascript
description: Illustrates a scenario where a `Proxy` object is used to intercept calls to a data provider. It highlights the need to trap the `then` method call when awaiting the data provider to prevent unintended execution.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_1

language: javascript
code:
```
const delayedDataProvider = new Proxy(restProvider, {
  get: (target, name, self) =>
    name === "then"
      ? // as we await for the dataProvider, JS calls then on it. We must trap that call or else the dataProvider will be called with the then method
        self
      : (resource, params) =>
          new Promise((resolve) =>
            setTimeout(
              () => resolve(restProvider[name](resource, params)),
              500,
            ),
          ),
});
```

---

title: Handling Escaped Characters in Await Using Binding
description: Illustrates the use of escaped unicode characters in `await using` bindings. Demonstrates that the JavaScript engine correctly parses and interprets escaped unicode characters as valid variable names in this context. This is useful when dealing with variable names containing special characters.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_1

language: javascript
code:
```
async function f() {
  await using \u0061b = c;
}
```

---

title: Ignoring Prettier Formatting With Comments
description: Illustrates how to use `prettier-ignore` comments to prevent Prettier from formatting specific sections of code, preserving the original formatting within the ignored regions.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_0

language: diff
code:
```
 oneArgument(
   // prettier-ignore
   (0, 1),
 );
 
 a =
-  // prettier-ignore
-  (0, 1);
+
+  (
+ // prettier-ignore
+ (0, 1)
+);
```

---

title: Ignoring Formatting for Array Initialization
description: Shows how to use `prettier-ignore` to maintain a specific array initialization format, preventing Prettier from reformatting the array elements.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_2

language: diff
code:
```
 export default function test() {
   return {
     matrix: // prettier-ignore
-      new Float32Array([
-      0, 0,
-      1, 0,
-      1, 1,
-      0, 1
-    ]),
+      new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
   };
 }
```

---

title: Modifying Arrow Function Parentheses
description: Illustrates how formatting changes the parentheses around an arrow function when a comment is present.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_3

language: diff
code:
```
-foo(() =>
-  // foo
-  {},
+foo(
+  (
+    // foo
+  ) => {},
 );
```

---

title: Formatting Function Calls with Long Arguments
description: Demonstrates how formatting adjusts function calls with long arguments, specifically how the `it` function is handled within a `forEach` loop.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_4

language: diff
code:
```
 fs.readdirSync(suiteLoc).forEach(function (testName) {
-  (skip ? it.skip : it)(
-    testName,
-    buildTest(binName, testName, opts),
-    2_000_000,
-  );
+  (skip
+    ? it.skip
+    : it)(testName, buildTest(binName, testName, opts), 2_000_000);
 });
 
 {
   (skip ? it.skip : it)(
     testName,
     buildTest(binName, testName, opts),
     2_000_000,
   );
 }
```

---

title: Handling Conditional Assignment - Diff
description: Demonstrates various complex conditional assignments using ternary operators. Highlights potential readability issues with deeply nested ternaries and suggests improvements for formatting.
source: crates/biome_js_formatter/report-es2015.md#_snippet_0

language: diff
code:
```
// concatened string in consequent should be visually distinguishable from alternate
// ... or maybe this is okay, because the colon is enough?
const avatar = has_ordered
  ? "https://marmelab.com/posters/avatar/longer-word-that-breaks-consequent-" +
    numberOfCustomers +
    ".jpeg"
  : undefined;

// Similarly, in the alternate:
const redirectUrl = pathName
  ? pathName
  : nextPathName + nextSearch ||
    defaultAuthParams.afterLoginUrl.makeThisLongerSoItBreaks;

// And another, more pathological case of the above:
const isEmpty = (obj) =>
  obj instanceof Date
    ? false
    : obj === "" ||
      obj === null ||
      obj === undefined ||
      obj === somethingThatIsLonger ||
      shallowEqual(obj, {});

// Again, this case is a bit hard to distinguish the alternate.
const eventsFromOrders =
  orderIds && orders
    ? orderIds.map((id) => ({
        type: "order",
        date: orders[id].date,
        data: orders[id],
      }))
    : [];

// Kinda weird to have dedents to the level of "return" in a function.
function foo() {
  return !linkTo
    ? false
    : typeof linkTo === "function"
      ? linkTo(record, reference)
      : linkToRecord(rootPath, sourceId, linkTo_as_string);
}
function foo2() {
  return React.isValidElement(emptyText)
    ? React.cloneElement(emptyText)
    : emptyText === ""
      ? " " // em space, forces the display of an empty line of normal height
      : translate(emptyText, { _: emptyText });
}

// Function call ideally wouldnt break break
const matchingReferencesError = isMatchingReferencesError(matchingReferences)
  ? translate(matchingReferences.error, {
      _: matchingReferences.error,
    })
  : null;

// This one is kinda confusing any way you slice it...
const obj = {
  error:
    matchingReferencesError &&
    (!input.value ||
      (input.value && selectedReferencesDataStatus === REFERENCES_STATUS_EMPTY))
      ? translate("ra.input.references.all_missing", {
          _: "ra.input.references.all_missing",
        })
      : null,
};

// I think we should indent after the inner || on this, and do better wtih the parens around the &&
const obj2 = {
  warning:
    matchingReferencesError ||
    (input.value && selectedReferencesDataStatus !== REFERENCES_STATUS_READY)
      ? matchingReferencesError ||
        translate("ra.input.references.many_missing", {
          _: "ra.input.references.many_missing",
        })
      : null,
};

// The boolean conditions in the test should look cohesive.
const selectedReferencesDataStatus =
  !isEmpty(value) && typeof value === "string" && !pattern.test(value)
    ? getMessage(message, { pattern }, value, values)
    : undefined;

// Would be nice if these two nested ternaries didn't look like a single one.
resolveRedirectTo(
  redirectTo,
  basePath,
  payload
    ? payload.id || (payload.data ? payload.data.id : null)
    : requestPayload
      ? requestPayload.id
      : null,
  payload && payload.data
    ? payload.data
    : requestPayload && requestPayload.data
      ? requestPayload.data
      : null,
);

const delayedDataProvider = new Proxy(restProvider, {
  get: (target, name, self) =>
    name === "then"
      ? // as we await for the dataProvider, JS calls then on it. We must trap that call or else the dataProvider will be called with the then method
        self
      : (resource, params) =>
          new Promise((resolve) =>
            setTimeout(
              () => resolve(restProvider[name](resource, params)),
              500,
            ),
          ),
});

function foo4() {
  return !match || match.length < 5
    ? line
    : match[1] + match[2] + match[3] + match[4];
}

function foo5() {
  return !match || match.length < 5
    ? foo(line)
    : match[1] + match[2] + match[3] + match[4];
}

function foo6() {
  return !match || match.length < 5
    ? linethatisverylongandbreaksthelinehooray
    : match[1] + match[2] + match[3] + match[4];
}

function foo7() {
  return !match || match.length < 5
    ? linethatisverylongandbreaksthelinehoorayjustabitlonger
    : match[1] + match[2] + match[3] + match[4];
}

const badComments = schema.model
  ? schema
  : // If model is an array where the items schema is a referred model then we need to use that
    schema.type === "array"
    ? schema.items
    : schema;

const anotherBadComment = refModel
  ? // If we're in a shared params file then reference the model name directly
    inSharedParamsFile
    ? refModel
    : // If we're not in a shared params file then reference the in-file type
      classRef()
  : // We don't have a model name, use the in-file name
    classRef();
```

---

title: Configuring Formatter Indentation Style
description: Demonstrates how to configure the formatter's indentation style in the `rome.json` configuration file. This example sets the indentation style to spaces, allowing customization of code formatting preferences.
source: ROME_CHANGELOG.md#_snippet_2

language: json
code:
```
{ "root": true, "formatter": { "indentStyle": "space" } }
```

---

title: Implementing Custom Integer Range Deserialization - Rust
description: Demonstrates how to implement a custom deserializer for an integer range using the `Deserializable` trait. The example defines a `Day` struct that represents a day between 1 and 365 and implements custom deserialization logic to ensure that the deserialized value falls within the valid range. It uses the `TextNumber` type to deserialize the value as a string, then attempts to parse it into a `Day`, reporting a diagnostic error if the value is out of range.
source: crates/biome_deserialize/README.md#_snippet_2

language: rust
code:
```
use std::str::FromStr;
use biome_deserialize::{Deserializable, DeserializableValue, DeserializationDiagnostic, TextNumber};

#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash, Ord, PartialOrd)]
pub struct Day(u16);

impl Day {
    pub const MIN: Day = Day(1);
    pub const MAX: Day = Day(365);
    pub fn get(&self) -> u16 {
        self.0
    }
}

impl Default for Day {
    fn default() -> Self {
        Self::MIN
    }
}

impl TryFrom<u16> for Day {
    type Error = &'static str;
    fn try_from(value: u16) -> Result<Self, Self::Error> {
        if (Self::MIN.get()..=Self::MAX.get()).contains(&value) {
            Ok(Self(value))
        } else {
            Err("A day must be between 1 and 365")
        }
    }
}

impl FromStr for Day {
    type Err = &'static str;
    fn from_str(s: &str) -> Result<Self, Self::Err {
        s.parse::<u16>()
            .map_err(|_error| "A day must be an integer between 1 and 365")
            .and_then(|value| Day::try_from(value))
    }
}

impl Deserializable for Day {
    fn deserialize(
        ctx: &mut impl DeserializationContext,
        value: &impl DeserializableValue,
        name: &str,
    ) -> Option<Self> {
        // We deserialize the value into a number represented as a string.
        let value_text = TextNumber::deserialize(ctx, value, name)?;
        // We attempt to convert the string into a `Day`.
        value_text.parse::<Day>().map_err(|error| {
            // If the conversion failed, then we report the error.
            ctx.report(DeserializationDiagnostic::new(error).with_range(value.range()));
        }).ok()
    }
}
```

language: rust
code:
```
use biome_deserialize::json::deserialize_from_json_str;
use biome_deserialize::Deserialized;
use biome_json_parser::JsonParserOptions;

let json = "42";
let Deserialized {
    deserialized,
    diagnostics,
} = deserialize_from_json_str::<Day>(&source, JsonParserOptions::default(), "path/to.json");
assert_eq!(deserialized, Some(Day(42)));
assert!(diagnostics.is_empty());

let json = "999";
let Deserialized {
    deserialized,
    diagnostics,
} = deserialize_from_json_str::<Day>(&source, JsonParserOptions::default(), "path/to.json");
assert_eq!(deserialized, None);
assert_eq!(diagnostics..len(), 1);
```

---

title: Formatting Return Statements
description: Demonstrates the formatting of return statements with long conditional expressions. The example shows that the formatter prefers an inline format rather than a multi-line format.
source: crates/biome_js_formatter/report.md#_snippet_12

language: diff
code:
```
-return (
-  someVeryLongStringA &&
-  someVeryLongStringB &&
-  someVeryLongStringC &&
-  someVeryLongStringD
-);
```

---

title: Formatting Function Declarations in While Loops
description: Demonstrates the formatting of function declarations within `while` loops. The example shows removal of space between `function` and `foo`.
source: crates/biome_js_formatter/report.md#_snippet_13

language: diff
code:
```
-while (false) function foo() {}
+while (false) function foo(){}
```

---

title: Ignoring Class Expression Decorators - JavaScript
description: Demonstrates how to use `prettier-ignore` to prevent formatting of class expression decorators. This is useful when specific formatting is desired for decorators that differs from the default.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_3

language: diff
code:
```
 // prettier-ignore
 (
+  // prettier-ignore
   @decorator
   class {}
 );
```

---

title: Ignoring Formatting of Expressions - JavaScript
description: Demonstrates the use of `prettier-ignore` and `eslint-disable-next-line` to prevent formatting of specific expressions. This is useful for maintaining a particular style that the formatter might otherwise alter.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_4

language: diff
code:
```
 function HelloWorld(x) {
-  // prettier-ignore
-  // eslint-disable-next-line
-  (x.a |
-    x.b).call(null);
+  (
+    // prettier-ignore
+    // eslint-disable-next-line
+    x.a |
+    x.b
+  ).call(null)
 }
```

---

title: Ignoring Comma Operator Formatting - JavaScript
description: Shows how to prevent formatting changes to comma operators using `prettier-ignore`. This allows developers to maintain specific formatting styles for comma-separated expressions.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_5

language: diff
code:
```
 a =
-  // prettier-ignore
-  (0, 1);
+  (
+ // prettier-ignore
+ (0, 1)
+);
```

---

title: Ignoring Async Await Formatting - JavaScript
description: Illustrates using `prettier-ignore` to prevent automatic formatting of `await` expressions within async functions. This preserves the original code structure and formatting around the `await` call.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_6

language: diff
code:
```
 async function foo() {
-  // prettier-ignore
-  // b
-  (await thing()).blah;
+  (
+  	// prettier-ignore
+  	// b
+	await thing()
+).blah
 }
```

---

title: Ignoring Matrix Formatting - JavaScript
description: Demonstrates how to use `prettier-ignore` to preserve the specific formatting of a matrix within a JavaScript code. This ensures that the visual structure of the matrix remains as intended by the developer.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_7

language: diff
code:
```
     matrix: // prettier-ignore
-      new Float32Array([
-      0, 0,
-      1, 0,
-      1, 1,
-      0, 1
-    ]),
+      new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
```

---

title: Refactoring Prettier Ignore Comments
description: Demonstrates how to properly apply a `prettier-ignore` comment in a TypeScript file. The change ensures that the `prettier-ignore` comment is correctly placed before the code that needs to be ignored.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_3

language: typescript
code:
```
export const foo =  (  // prettier-ignore  bar as Baz).qux;
```

---

title: Formatting Mapped Types with Prettier Ignore
description: Demonstrates how the formatter handles `prettier-ignore` comments within mapped types. The changes involve moving or removing `prettier-ignore` comments to achieve correct formatting.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_4

language: typescript
code:
```
type a = {    // prettier-ignore    [A in B]: C  |  D  };

type a = {    [      // prettier-ignore      A in B    ]: C  |  D  };

type a = {  [A in B]: C | D;};

type a = {  [A in B]: // prettier-ignore  C | D;};

type a = {    [      /* prettier-ignore */      A in B    ]: C  |  D  };

type a = {  [A in B]: C | D;};

type a = {  [A in B]: /* prettier-ignore */  C | D;};

type a = {    /* prettier-ignore */ [A in B]: C  |  D  };

type a = {  [/* prettier-ignore */ A in B]: C | D;};

type a = {  [A in B]: /* prettier-ignore */ C | D;};

type a = {    /* prettier-ignore */    [A in B]: C  |  D  };
```

---

title: Formatting Nested Unions with Prettier Ignore
description: Demonstrates the formatting changes for nested union types with a `prettier-ignore` comment. The changes involve adjusting parentheses and line breaks around the ignored section to improve readability.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_5

language: typescript
code:
```
export type a =  // foo  | (foo1 & foo2)  // bar  | (bar1 & bar2)  // prettier-ignore  | (      | (aaaaaaaaaaaaa & 1)      // b      | (bbbbbbbbbbbbb & 2)    )  // baz  | (baz1 & baz2);

export type b =  // foo  | (foo1 & foo2)  // bar  | (bar1 & bar2)  // prettier-ignore  | (      | (aaaaaaaaaaaaa & 1)      // b      | (bbbbbbbbbbbbb & 2)    )  // baz  | (baz1 & baz2);
```

---

title: Wrapping Parenthesized Type With Prettier Ignore
description: Illustrates how the formatter handles a parenthesized type with a `prettier-ignore` comment. The change involves wrapping the type alias `aa` within parentheses.
source: crates/biome_js_formatter/report_incompatible.md#_snippet_6

language: typescript
code:
```
type Foo =  // prettier-ignore  (    aa  );
```

---

title: Formatting Async Arrow Functions
description: Demonstrates how async arrow functions are formatted, especially when dealing with newlines before the arrow.  Shows that the formatting in this particular case is incorrect.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_6

language: javascript
code:
```
async;
x;
=> x
```

---

title: Ignoring Class Expression Decorators
description: Demonstrates how to use `prettier-ignore` to prevent formatting of class expression decorators. This is useful when you want to preserve specific formatting for decorators that might be altered by the formatter.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_4

language: diff
code:
```
+  // prettier-ignore
   @decorator
   class {}
 );
```

---

title: Ignoring Formatting within a Function
description: Illustrates the use of `prettier-ignore` and `eslint-disable-next-line` to disable formatting and linting for a specific section of code within a function. The example showcases a bitwise operation that is intentionally left unformatted.
source: crates/biome_js_formatter/report-es2024+.md#_snippet_5

language: diff
code:
```
 function HelloWorld(x) {
-  // prettier-ignore
-  // eslint-disable-next-line
-  (x.a |
-    x.b).call(null);
+  (
+    // prettier-ignore
+    // eslint-disable-next-line
+    x.a |
+    x.b
+  ).call(null)
 }
 
 function HelloWorld(x) {
   // prettier-ignore
+
   (
     // eslint-disable-next-line
     x.a |
     x.b
   ).call(null)
 }
```

---

title: Handling Parenthesized Sequence Expressions
description: Illustrates a case where the formatter has issues with parenthesized sequence expressions containing comments. The code snippet shows the original formatting and a commented-out section indicating a parsing issue.
source: crates/biome_js_formatter/report-es2015.md#_snippet_2

language: diff
code:
```
-console.log(
-  /* 1 */
-  /* 2 */
-  /* 3 */
-  (first,
-  /* 4 */
-  /* 5 */
-  /* 6 */
-  /* 7 */
-  last),
-  /* 8 */
-  /* 9 */
-  /* 10 */
-);
+// FIXME
+// TODO: parse issue
+// console.log(
+//   /* 1 */
+//   (
+//     /* 2 */
+//     (
+//       /* 3 */
+//       first
+//       /* 4 */
+//     )
+//     /* 5 */
+//     ,
+//     /* 6 */
+//     (
+//       /* 7 */
+//       last
+//       /* 8 */
+//     )
+//     /* 9 */
+//   )
+//   /* 10 */
+// );
```

---
